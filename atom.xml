<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yvainefire.github.io</id>
    <title>YvaineFire_block</title>
    <updated>2021-04-27T10:52:34.470Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yvainefire.github.io"/>
    <link rel="self" href="https://yvainefire.github.io/atom.xml"/>
    <subtitle>Rush Rush B</subtitle>
    <logo>https://yvainefire.github.io/images/avatar.png</logo>
    <icon>https://yvainefire.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, YvaineFire_block</rights>
    <entry>
        <title type="html"><![CDATA[C语言 常量指针和指针常量]]></title>
        <id>https://yvainefire.github.io/post/c-yu-yan-chang-liang-zhi-zhen-he-zhi-zhen-chang-liang/</id>
        <link href="https://yvainefire.github.io/post/c-yu-yan-chang-liang-zhi-zhen-he-zhi-zhen-chang-liang/">
        </link>
        <updated>2021-04-27T10:52:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常量指针">常量指针</h2>
<p>指针指向的内容是常量，用这个常量指针无法改变指针指向的内容，但是可以用另一个指向相同地址的非常量指针去改变他们共同指向的内容。</p>
<pre><code class="language-c">int A = 1;
int B = 2;
const int * C = &amp;A; //定义一个常量指针
int const * B = &amp;A; //定义一个常量指针
</code></pre>
<h2 id="指针常量">指针常量</h2>
<p>指针常量是指这个指针是一个常量，即不能将这个指针指向其它的地址，即不能改变这个指针本身。</p>
<pre><code class="language-c">int A = 1;
int B = 2;
int * const n =&amp;A; //定义一个指针常量
</code></pre>
<p><strong>注：区分常量指针和指针常量，可以通过const在 * 的左边还是右边。</strong></p>
<h2 id="常量指针常量">常量指针常量</h2>
<p>同时具有常量指针和指针常量的特点，既无法修改指针指向的内容也无法修改指针本身。</p>
<pre><code class="language-c">int A = 1;
const int * const C = &amp;A;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++面向对象 data member初始化]]></title>
        <id>https://yvainefire.github.io/post/cmian-xiang-dui-xiang-cheng-yuan-chu-shi-hua/</id>
        <link href="https://yvainefire.github.io/post/cmian-xiang-dui-xiang-cheng-yuan-chu-shi-hua/">
        </link>
        <updated>2021-04-08T12:33:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="constructor">constructor</h2>
<p>C++的所有成员未初始化的成员通过构造函数进行操作，构造函数（constructor）</p>
<p>构造函数的特点：</p>
<ul>
<li>名称和class的名称一样</li>
<li>构造函数的不应该指定返回类型</li>
<li>构造函数允许被重载</li>
<li>构造函数在类被定义后根据传入参数的类型进行选择并调用</li>
</ul>
<h2 id="destructor">destructor</h2>
<p>与构造函数对应的就是析构函数（destructor），对构造函数中分配的资源进行释放回收，完成heap内存的管理。</p>
<p>析构函数的特点：</p>
<ul>
<li>析构函数的名称是class名前加个~</li>
<li>析构函数没有返回值</li>
<li>析构函数不带任何参数</li>
<li>析构函数不能被重载</li>
</ul>
<h2 id="default-constructor">default constructor</h2>
<p>不需要任何参数，不接受参数或者是提供默认参数</p>
<pre><code class="language-c++">class_name(int a=1, int b=2){
	data_member_1 = a;
	data_member_2 = b;
}
</code></pre>
<h2 id="member-initialization-list">Member Initialization List</h2>
<p>C++的的构造函数除了具有一般函数的特征外。还可以具有初始化列表。初始化列表更在函数参数的括号后面，以 : 开头</p>
<pre><code class="language-c++">class_name(int a, int b):data_member_1(a),data_member_2(b)
{

}
</code></pre>
<h2 id="memberwise-initialzation">Memberwise Initialzation</h2>
<p>用一个class object 来初始化另一个object</p>
<p>eg:</p>
<pre><code class="language-c++">class_name obj_1(paraments);
class_name obj_2 = obj_1;
</code></pre>
<p>把obj_1这个类里面的成员变量的值直接通过operator=赋给obj_2。</p>
<p>这里可能会出现一个问题如果成员变量里面有的值是指针形式的，那么这样的操作会使指针指向同一个地址。如果每个class object的destructor都对之指针指向的内容进行回收那么就可能会导致一些错误。为了解决这个问题可以采用重载一个const class_name &amp;object_name的构造函数，进行手动的赋值操作，申请一个新的内存空间用于指针指向。</p>
<h2 id="c构造函数的两个阶段">C++构造函数的两个阶段</h2>
<h3 id="初始化阶段">初始化阶段</h3>
<ul>
<li>调用初始化列表</li>
<li>未初始化的类成员（不在初始化列表）调用默认构造函数</li>
</ul>
<h3 id="计算阶段">计算阶段</h3>
<p>在执行完初始化阶段后，执行构造体函体内的赋值操作，进行初始化。</p>
<p><strong>具体顺序</strong>：成员变量被初始化的顺序是由成员变量在class里面声明的顺序决定的，先声明的先初始化。初始化的顺序是先利用初始化参数表进行初始化，根据初始化参数表提供的参数类型，选择相应的构造函数进行初始化，可以把初始化参数表种没有提到的参数，默认是其调用了不含参数的构造函数，也就是说所有的未初始化的成员变量如果有不含参数的构造方法都会在调用初始化参数列表时调用一种构造方法进行构造。然后再根据构造函数里面的计算赋值阶段。</p>
<p>eg:</p>
<pre><code class="language-c++">class BaseTest1{
public:
    BaseTest1();
    BaseTest1(const BaseTest1&amp; t1);
    BaseTest1&amp; operator=(const BaseTest1&amp; t1);
private:
    int a;
};

BaseTest1::BaseTest1()
{
    cout &lt;&lt; &quot;BaseTest1 Constructor&quot; &lt;&lt; endl;
    this-&gt;a = 0;
}

BaseTest1::BaseTest1(const BaseTest1 &amp;t1)
{
    cout &lt;&lt; &quot;BaseTest1 Copy Constructor&quot; &lt;&lt; endl;
    this-&gt;a = t1.a;
}

BaseTest1&amp; BaseTest1::operator=(const BaseTest1 &amp;t1)
{
    cout &lt;&lt; &quot;BaseTest1 assignment&quot; &lt;&lt; endl;
    this-&gt;a = t1.a;
    return *this;
}

class BaseTest2
{
public:
    BaseTest2()
    {
        cout &lt;&lt; &quot;BaseTest2 Constructor&quot; &lt;&lt; endl;
        this-&gt;a = 0;
    }
    BaseTest2(const BaseTest2&amp; t)
    {
        cout &lt;&lt; &quot;BaseTest2 Copy Constructor&quot; &lt;&lt; endl;
        this-&gt;a = t.a;
    }
    BaseTest2&amp; operator=(const BaseTest2&amp; t)
    {
        cout &lt;&lt; &quot;BaseTest2 assignment&quot; &lt;&lt; endl;
        this-&gt;a = t.a;
        return *this;
    }
private:
    int a;
};


class Test{
public:
    Test(BaseTest1&amp; t1, BaseTest2&amp; t2):test1(t1)
    {
        this-&gt;test2 = t2;
    }

public:
    BaseTest2 test2;
    BaseTest1 test1;
};


int main(int argc, char* args[])
{
    BaseTest1 test1;
    BaseTest2 test2;
    Test test(test1, test2);
}
————————————————
版权声明：代码为CSDN博主「惜暮」的原创
代码链接：https://blog.csdn.net/u010853261/article/details/85036025
</code></pre>
<p>执行结果：</p>
<pre><code>BaseTest1 Constructor
BaseTest2 Constructor
BaseTest2 Constructor
BaseTest1 Copy Constructor
BaseTest2 assignment
</code></pre>
<p>使用初始化列表可以减少计算阶段的赋值操作，毕竟大多数时候成员变量在调用初始化列表的时候都会采用一种构造方法进行初始化。</p>
<p>注意：在列表调用初始化阶段时如果涉及到成员变量的作为参数，则一定要注意成员变量在class中定义的顺序，防止未定义的情况出现。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL标准库]]></title>
        <id>https://yvainefire.github.io/post/stl-biao-zhun-ku/</id>
        <link href="https://yvainefire.github.io/post/stl-biao-zhun-ku/">
        </link>
        <updated>2021-04-08T08:21:48.000Z</updated>
        <content type="html"><![CDATA[<p>C++标准库 能看见source code</p>
<p>STL是C++标准库中的部分</p>
<p>header files:不带.h</p>
<p>name space:命名空间，避免命名冲突</p>
<p>常用网站：</p>
<ul>
<li>CPlusPlus.com</li>
<li>CppReference.com</li>
<li>gcc.gnu.org</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 面向对象 类的声明和定义]]></title>
        <id>https://yvainefire.github.io/post/c-mian-xiang-dui-xiang-lei-de-sheng-ming-he-ding-yi/</id>
        <link href="https://yvainefire.github.io/post/c-mian-xiang-dui-xiang-lei-de-sheng-ming-he-ding-yi/">
        </link>
        <updated>2021-04-08T08:20:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="类的声明">类的声明</h2>
<p>类的声明以关键是 class开始，</p>
<pre><code class="language-c++">class class_name;
</code></pre>
<p>类的前置声明只是告诉编译器有这个类的存在，同时可以定义类指针</p>
<h2 id="类的定义">类的定义</h2>
<p>class 声明  +  声明后的主体</p>
<pre><code class="language-c++">class class_template{
pubilic:

private:

}
</code></pre>
<p>主体内包括data member和member function，同时这两种都具有public或者private属性，public属性的可以被类外访问，private属性的只能被类里面的东西访问。</p>
<p>member function 必须在类里面声明，但不一定在类里面定义。在类里面定义的时候会被默认定义为inline函数。在类外定义是需要特殊指定是哪个类的函数。</p>
<pre><code class="language-c++">class class_template{
pubilic:
	void function_1(int a);
	void function_2(int b);

	void funciton_2(int b)
	{
		.......
	}
private:
	int c;
}

void class_template::function_2(int a)
{
	.......
}
</code></pre>
<p>data member必须通过特殊的方式进行初始化即构造函数（constructor）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 泛型指针]]></title>
        <id>https://yvainefire.github.io/post/c-fan-xing-zhi-zhen/</id>
        <link href="https://yvainefire.github.io/post/c-fan-xing-zhi-zhen/">
        </link>
        <updated>2021-04-08T08:20:29.000Z</updated>
        <content type="html"><![CDATA[<p>C++的泛型指针是针对容器元素而言的，相当于是容器的指针</p>
<h2 id="泛型指针的定义">泛型指针的定义</h2>
<pre><code class="language-c++">vector&lt;class&gt;::iterator iter = vertor_template.begin();
//class 是vector的类型，vec_template是一个已经定义的容器。begin()是这个容器的第一个元素的指针
vector&lt;class&gt;::iterator iter = vertor_template.end();
//end 是这个容器的最后一个元素的指针
</code></pre>
<h2 id="泛型指针的操作">泛型指针的操作</h2>
<p>具有和一般指针一样的dereference（提领 *），inequality(不等 ！=)，increment（递增， ++）等操作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 函数编写]]></title>
        <id>https://yvainefire.github.io/post/c-han-shu-bian-xie/</id>
        <link href="https://yvainefire.github.io/post/c-han-shu-bian-xie/">
        </link>
        <updated>2021-04-03T07:23:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="使用带默认参数的函数">使用带默认参数的函数</h2>
<p>C++提供了带默认参数的函数。</p>
<p>eg:</p>
<pre><code class="language-c++">void function_paramt(int a, int b, int c = 1)
{
	....
	....
}
</code></pre>
<p>在函数的定义或声明中可以为其添加默认的参数，当调用这个函数的时候，如果没有第三个参数的形参，则默认等于1。否则以形参的值为准。</p>
<p>注意在使用带默认参数的函数时有两条规则：</p>
<ul>
<li>对默认参数的解析是从右往左开开始，所以从左往右第一个使用默认参数的参数其右边的所以参数都必须使用默认参数。</li>
<li>在函数的声明和定义中只能够有一个地方使用了默认参数，建议在函数声明的位置使用默认参数。</li>
</ul>
<h2 id="使用inline声明函数">使用inline声明函数</h2>
<p>为了提高函数的效率减少函数之间调用所产生的开销，可以使用inline来声明一个函数，从而使该函数内部调用的函数，在编译的时候能展开，从而减少了一个函数对另一个函数的调用。</p>
<p>inline的作用简单来说就是对函数进行展开。</p>
<p>eg:</p>
<pre><code class="language-c++">inline void il_templet(int a, int b)
{
	fun1();
	fun2();
	.......
}
</code></pre>
<p>注意：inline只是对编译器提出的一种请求，并不是强制性的。所以编译是否会执行，还需要根据编译器而定。</p>
<h2 id="函数的重载">函数的重载</h2>
<p>不同于C语言，C++可以对函数进行重载，所谓重载也就是指对一个同名的函数可以根据其参数的不同而进行区别。这里参数不同可以指参数的类型不同，参数的数量不同。</p>
<p>在调用函数的时候，根据调用时所给定的形参来选择相应的函数进行调用。</p>
<p>eg:</p>
<pre><code class="language-c++">void func_overlaoding_1();
void func_overlaoding_1(int a);
void func_overlaoding_1(string a);
void func_overlaoding_1(int a, int b);
......
</code></pre>
<p>注意：返回类型并不作为区分函数重载的依据，因为调用函数的时候，用时候并不会使用到其返回类型，这就导致了编译器不能对齐进行解析。</p>
<h2 id="模板函数">模板函数</h2>
<p>当一个几个函数函数体相似，而仅仅是函数中某个变量的数据类型不一样的时，可以使用定义一个函数模板方式，来减少定义多个类似的函数。</p>
<p>定义一个函数模板，最开始以关键字template开头，然后用&lt; &gt;包含多个标识符。</p>
<p>eg:</p>
<pre><code class="language-c++">template &lt;typename elemType&gt;
void template_function(int a, vector&lt;elemType&gt; &amp;vec)
{
.......
}
</code></pre>
<p>使用一个函数模板，先定义模板中未定义的参数的类型</p>
<p>eg:</p>
<pre><code class="language-c++">vector&lt;int&gt; ivec;
template_function(a, ivec);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ point & reference]]></title>
        <id>https://yvainefire.github.io/post/point-and-reference/</id>
        <link href="https://yvainefire.github.io/post/point-and-reference/">
        </link>
        <updated>2021-04-02T13:33:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="reference">reference</h2>
<p>引用类型：通过将声明符写成&amp;d的形式来定义引用声明，d是定义的变量的名称。</p>
<p>eg:</p>
<pre><code class="language-c++">int ival = 1024;
int &amp;refVal = ival;
</code></pre>
<p>引用类型不是对初始对象的拷贝，而是将初值对象与其绑定在一起。而且一旦该引用类型初始化完成，它将一直与处置对象绑定，不能更改它所绑定的引用对象。同时对绑定的所有操作等价于对初始对象的所有操作。</p>
<p>引用本身不是一个对象，所以不能定义引用的引用。</p>
<h2 id="pointer">pointer</h2>
<p>指针是指向另外一种类型的复合类型。通过将声明符写成*d的形式，其中d是变量的名。</p>
<p>eg：</p>
<pre><code class="language-c++">int *ip;
double *dp;
</code></pre>
<p>注意：指针所指向对象的类型和指针声明的类型必须保持一致。对空指针进行操作可能会出现未知的错误。</p>
<h3 id="空指针">空指针</h3>
<p>空指针是指不指向任何对象的指针</p>
<p>常见空指针的声明方法</p>
<pre><code class="language-c++">//为了避免误解，最好把*写在变量的前面而不要写在类型前面
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL;


</code></pre>
<p>注意：还有一种情况是指向动态分配的空间的地址被回收了之后的指针也是空指针。</p>
<h3 id="void">void *</h3>
<p>可以存放任意对象的地址，也就是说可以存放任意对象的指针</p>
<h3 id="函数指针">函数指针</h3>
<p>函数指针是指向函数的指针。它必须指明所指函数的返回类型及参数列表。</p>
<p>使用函数指针的方式一：</p>
<ul>
<li>
<p>先声明一个函数指针</p>
<p>eg:</p>
<pre><code class="language-c++">const vector&lt;int&gt; (*seq_ptr)(int);
</code></pre>
</li>
<li>
<p>在用一个类型与之匹配的函数对其进行初始化</p>
</li>
</ul>
<p>使用函数指针的方式二：</p>
<ul>
<li>
<p>用typedef定义函数指针</p>
<p>eg:</p>
<pre><code class="language-c++">typedef vector&lt;int&gt; (*fun_pointer)(int);
</code></pre>
</li>
<li>
<p>用定义的这个函数指针的函数名，作为一个新的类型去声明一个函数指针</p>
<p>eg:</p>
<pre><code class="language-c++">fun_pointer fp_1;
</code></pre>
</li>
<li>
<p>再用一个与之对的函数对其进行初始化</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于np.copy()是浅复制还是深复制?]]></title>
        <id>https://yvainefire.github.io/post/guan-yu-npcopyshi-qian-fu-zhi-huan-shi-shen-fu-zhi/</id>
        <link href="https://yvainefire.github.io/post/guan-yu-npcopyshi-qian-fu-zhi-huan-shi-shen-fu-zhi/">
        </link>
        <updated>2021-03-30T13:22:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id=""></h1>
<h2 id="官方文档">官方文档：</h2>
<p>Note that np.copy is a shallow copy and will not copy object elements within arrays. This is mainly important for arrays containing Python objects. The new array will contain the same object which may lead to surprises if that object can be modified (is mutable)</p>
<p>但是如果复制的对象不是object elements，则可以看作是deepcopy，最安全的方法还是使用copy.deepcopy()。</p>
<h2 id="eg">eg:</h2>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/pytest.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++杂项知识]]></title>
        <id>https://yvainefire.github.io/post/cza-xiang-zhi-shi/</id>
        <link href="https://yvainefire.github.io/post/cza-xiang-zhi-shi/">
        </link>
        <updated>2021-03-08T13:51:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1namespace">1.namespace</h2>
<p>namespace(命名空间)：是一种将库名称封装起来的方法。避免发生命名冲突。所谓命名冲突是指，应用程序的两个不同的实体有相同的名称。</p>
<h3 id="使用namespace来解决命名冲突的问题">使用namespace来解决命名冲突的问题</h3>
<pre><code class="language-c">using namesapce 命名空间名;
</code></pre>
<p>这样会使后续的代码将使用指定的命名空间中的名称。</p>
<p>一般使用标准库的命名空间：std</p>
<h3 id="自定义命名空间的方式">自定义命名空间的方式</h3>
<p>namespace 命名空间名{</p>
<p>​		函数1...</p>
<p>​		函数2...</p>
<p>​		变量1...</p>
<p>​		变量2...</p>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++文件的读写]]></title>
        <id>https://yvainefire.github.io/post/cwen-jian-de-du-xie/</id>
        <link href="https://yvainefire.github.io/post/cwen-jian-de-du-xie/">
        </link>
        <updated>2021-03-08T13:51:12.000Z</updated>
        <content type="html"><![CDATA[<p>包含 fstream 头文件</p>
<h2 id="输出">输出</h2>
<h3 id="定义输出的文件变量">定义输出的文件变量</h3>
<p>ofstream outfile_name(&quot;文件地址&quot;);</p>
<p><strong>文件不存在时，会创建一个新的文件</strong></p>
<p>文件存在的时候，可以通过参数对其设置是在原文件尾部追加还是直接覆盖。默认为覆盖，添加如下参数变为追加</p>
<p>ofstream outfile_name(&quot;文件地址&quot;, ios_base::app);</p>
<h3 id="判断文件是否打开成功">判断文件是否打开成功</h3>
<pre><code class="language-c++">if (!out_file_name)
	文件打开失败
......
</code></pre>
<h3 id="使用文件进行输出">使用文件进行输出</h3>
<pre><code class="language-c++">outfile_name &lt;&lt; 输出内容;		
</code></pre>
<h2 id="输入">输入</h2>
<h3 id="定义输入的文件变量">定义输入的文件变量</h3>
<p>ifstream infile_name(&quot;文件地址&quot;);</p>
<h3 id="判断文件是否打开成功-2">判断文件是否打开成功</h3>
<pre><code class="language-c++">if (!in_file_name)
	文件打开失败
......
</code></pre>
<h3 id="使用文件进行输入">使用文件进行输入</h3>
<pre><code>in_flie_name &gt;&gt; 变量名
</code></pre>
<h2 id="同时输出和输入">同时输出和输入</h2>
<h3 id="定义输入输出文件">定义输入输出文件</h3>
<p>fstream in_and_out_file_name(&quot;文件地址&quot;)</p>
<h3 id="判断文件是否打开成功-3">判断文件是否打开成功</h3>
<pre><code class="language-c++">if (!in_and_out_file_name)
	文件打开失败
......
</code></pre>
]]></content>
    </entry>
</feed>