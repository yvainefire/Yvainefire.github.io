<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yvainefire.github.io</id>
    <title>YvaineFire_block</title>
    <updated>2020-07-31T09:30:03.254Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yvainefire.github.io"/>
    <link rel="self" href="https://yvainefire.github.io/atom.xml"/>
    <subtitle>Rush Rush</subtitle>
    <logo>https://yvainefire.github.io/images/avatar.png</logo>
    <icon>https://yvainefire.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, YvaineFire_block</rights>
    <entry>
        <title type="html"><![CDATA[多进程]]></title>
        <id>https://yvainefire.github.io/post/duo-jin-cheng/</id>
        <link href="https://yvainefire.github.io/post/duo-jin-cheng/">
        </link>
        <updated>2020-07-30T07:25:38.000Z</updated>
        <content type="html"><![CDATA[<p>#一. fork函数</p>
<h2 id="1关于fork函数">1.关于fork()函数</h2>
<p>pid_t fork(void);</p>
<p>创建一个新的进程，对于原进程而言该进程是子进程。</p>
<p>注意子进程和父进程的关系</p>
<h2 id="2关于返回值">2.关于返回值</h2>
<p>返回值有两个</p>
<p>对于子进程而言返回值为0</p>
<p>对于父进程而言，返回值是子进程的进程号</p>
<p><strong>为什么返回值会设置两个</strong>：因为对于一个父进程而言，是很难获得其子进程的进程号的，毕竟 一个父进程可能会有多个子进程。所以对于父进程而言，返回值设置其子进程的进程号，方便  父进程进行记录。而对于子进程而言，就很容易找到其父进程对应的进程号，使用getppid()函数。<br>
出错返回-1</p>
<h2 id="3关于拷贝">3.关于拷贝</h2>
<p>os会分配新的内存空间和内核数据结构给子进程</p>
<p>父进程中的部分代码，数据会拷贝到子进程中包括父进程的数据空间，堆，栈，还包括缓冲区的数据。这些拷贝的东西都是父本，所以是不会进行数据共享的，包括信号量。对于代码拷贝一定要注意：只拷贝位于fork()之后的代码，同时这里的拷贝不是真正的拷贝，只能说是代码的共享。这里特别注意循环结构，</p>
<p><strong>父子进程是相对的</strong>！！！！</p>
<p><strong>特别注意在带循环的进程创建的时候，在父进程创建子进程后，子进程拷贝的代码是for()位置当前未执行完的代码，即还需要考虑仍需执行的循环的次数。若该子进程会进行fork()创建对他而言的子进程，则在以此子进程为主进程的进程中，此子进程充当父进程。即父子进程是相对的额，是根据两进程的相对关系而言的。这里特别要注意，使用for进行fork()时一共创建的进程不是1+n个！！！</strong></p>
<p>两段代码：<br>
代码1</p>
<pre><code class="language-c">for(int i=0;i&lt;3;i++)  
{    
    if(pid=fork())    
    {      
        printf(&quot;%d\n&quot;,getpid());    
    }    
    else    
    {      
        printf(&quot;%d\n&quot;,getpid());    
    }      
}
</code></pre>
<p>代码2</p>
<pre><code class="language-c">int i=1;

  while((pid=fork()))    
  {            
      printf(&quot;pid:%d i:%d\n&quot;,getpid(),i);      
      if(i&gt;5)      
      {                  
          break;      
      }                      
      i++;        
  }    

printf(&quot;pid:%d\n&quot;,getpid());
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数指针]]></title>
        <id>https://yvainefire.github.io/post/han-shu-zhi-zhen/</id>
        <link href="https://yvainefire.github.io/post/han-shu-zhi-zhen/">
        </link>
        <updated>2020-07-30T07:07:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一函数指针和函数首地址">一.函数指针和函数首地址</h2>
<p>地址的联系</p>
<p>如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，<strong>这段存储空间的首地址称为这个函数的地址</strong>。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫<strong>作函数指针变量</strong>，简称函数指针。</p>
<h2 id="二函数指针的定义方式">二.函数指针的定义方式</h2>
<p>然而函数指针的定义和普通指针的定义事不同的。</p>
<p>函数指针的定义方式：</p>
<pre><code>函数返回值类型 (* 指针变量名) (函数参数列表);
</code></pre>
<p>例：</p>
<pre><code class="language-c"># include &lt;stdio.h&gt;
int Max(int, int);  //函数声明
int main(void){    
    int(*p)(int, int);  //定义一个函数指针    
    int a, b, c;    
    p = Max;  //把函数Max赋给指针变量p, 使p指向Max函数    
    
    printf(&quot;please enter a and b:&quot;);    
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);    
    c = (*p)(a, b);  //通过函数指针调用Max函数    
    printf(&quot;a = %d\nb = %d\nmax = %d\n&quot;, a, b, c);   
    
    return 0;
}
int Max(int x, int y)  //定义Max函数
{    
    int z;    
    if (x &gt; y) {        
        z = x;    
    }else 
    {        
        z = y;    
    }    
    return z;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对齐]]></title>
        <id>https://yvainefire.github.io/post/dui-qi/</id>
        <link href="https://yvainefire.github.io/post/dui-qi/">
        </link>
        <updated>2020-07-30T07:03:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一字节对齐的概念">一.字节对齐的概念</h2>
<p>计算机系统对基本数据类型的合法地址做了一些限制，这种限制称为对齐。</p>
<p>如：要求某些数据的地址只能以1或2或8或16的倍数。</p>
<h2 id="二字节对齐的原因">二.字节对齐的原因</h2>
<h3 id="1性能">1.性能</h3>
<p>字节对齐的根本原因在于提高数据的访问的效率。主要在于减少数据访问的次数，因为不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。如x86的一个总线周期只能访问偶地址的数据，所以若不进行对齐，一个原本可以一次访存获得的数据则需要2次甚至更多次才能得到。</p>
<h3 id="2平台原因">2.平台原因</h3>
<p>不是所有的硬件平台都能访问到任意地址上的任意数据</p>
<h2 id="三几种对齐的方式">三.几种对齐的方式</h2>
<h3 id="1数据类型自身的对齐自然对齐">1.数据类型自身的对齐(自然对齐)</h3>
<p>存放变量的地址为该变量在改平台上对应的数据类型大小的整数倍。</p>
<h3 id="2结构体或类的自身对齐">2.结构体或类的自身对齐</h3>
<p>结构体或类的首地址是其成员中自身对齐值最大的那个值的整数倍。</p>
<h3 id="3指定对齐值">3.指定对齐值</h3>
<p>#pragma pack (value)时的指定对齐值value。</p>
<p>例：#pragma pack (5)</p>
<p>int a = 4;</p>
<p>int b = 9;</p>
<p>即：按照5字节进行对齐</p>
<h3 id="4数据成员结构体和类的有效对齐值">4.数据成员，结构体和类的有效对齐值</h3>
<p>有效对齐值 = min{自身对齐值，当前指定对齐值}</p>
<h2 id="四结构体数据的对齐问题">四.结构体数据的对齐问题</h2>
<p>数据结构中的数据变量都是按照定义的先后顺寻进行存放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整 (即结构体成员变量占用总长度为结构体有效对齐值的整数倍) 。</p>
<ol>
<li>结构体字节对齐的细节和具体编译器实现相关，但一般而言满足三个准则： 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；</li>
<li>结构体每个成员相对结构体首地址的偏移量(offset注意偏移量是从0开始的)都是min{本成员大小,当前有效对齐值}的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)；</li>
<li>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。</li>
</ol>
<p>第一条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。</p>
<p>第二条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是min{本成员大小,当前有效对齐值}的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。</p>
<p>第三条：结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第三条，否则就必须在最后填充几个字节以达到本条要求。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ucosii运行流程]]></title>
        <id>https://yvainefire.github.io/post/ucosii-yun-xing-liu-cheng/</id>
        <link href="https://yvainefire.github.io/post/ucosii-yun-xing-liu-cheng/">
        </link>
        <updated>2020-07-28T13:04:04.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="ucosii运行流程">ucosii运行流程</h1>
<h2 id="一系统时钟中断额初始化">一.系统时钟中断额初始化</h2>
<p>SysTick中断初始化，在轮转调度过程中，需要一个时钟中断来进行任务的切换。时钟中断的频率就是系统的心跳，也被称为时基，它决定了操作系统进行任务切换的频率。</p>
<h2 id="二操作系统初始化">二.操作系统初始化</h2>
<h3 id="1osinithookbegin">1.OSInitHookBegin()</h3>
<p>主要进行一些扩展功能的初始化</p>
<h3 id="2os_initmisc">2.OS_InitMisc()</h3>
<p>主要作用：进行杂项变量的初始化，主要有以下内容需要被初始化</p>
<pre><code class="language-c">OSIntNesting    		中断嵌套层数清零
OSLockNesting			
OSTaskCtr				任务计数清零
OSRunning				操作系统运行标志位清零
OSCtxSwCtr				任务切换计数清零
OSIdleCtr				
</code></pre>
<h3 id="3os_initrdylist">3.OS_InitRdyList()</h3>
<p>就绪队列的初始化，所谓就绪队列指由就绪任务构成的队列，但是这里实际上初始化的并不是队列，就绪队列里面保存的也不是就绪任务的TCB。</p>
<pre><code class="language-c">//以下是就绪队列实现的定义和初始化的代码
typedef unsigned char INT8U;

typedef  INT8U    OS_PRIO;

OS_EXT  OS_PRIO           OSRdyTbl[OS_RDY_TBL_SIZE];

for (i = 0u; i &lt; OS_RDY_TBL_SIZE; i++) {
        OSRdyTbl[i] = 0u;
    }

</code></pre>
<p>从这里可以看出，就绪队列的本质是一个8位无符号整型数组，仅仅保存的是一个整型，而不是TCB或者TCB指针。</p>
<p>为什么仅仅保存整型就可以表示就绪队列呢？这个以后再说。</p>
<p>除了初始化就绪队列，还初始化了两个与优先级相关的变量以及两个和任务TCB相关的量。<br>
OSPrioCur	   		保存当前任务的优先级<br>
OSPrioHighRdy      保存当前就绪队列优先级最高的任务的优先级<br>
OSTCBCur 	          保存当前任务的TCB指针<br>
OSTCBHighRdy      保存当前就绪队列中最高优先级任务的TCB指针</p>
<h3 id="4os_inittcblist">4.OS_InitTCBList ()</h3>
<p>初始化TCB链表，这里主要强调的链表，主要是把在头文件里声明的</p>
<p>OS_TCB	OSTCBTbl[OS_MAX_TASKS + OS_N_SYS_TASKS];		这个TCB数组拆开然后用指针将其连接起来。</p>
<pre><code class="language-c">for (ix = 0u; ix &lt; (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
        ix_next =  ix + 1u;
        ptcb1   = &amp;OSTCBTbl[ix];
        ptcb2   = &amp;OSTCBTbl[ix_next];
        ptcb1-&gt;OSTCBNext = ptcb2;
}

ptcb1                   = &amp;OSTCBTbl[ix];
ptcb1-&gt;OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
OSTCBFreeList           = &amp;OSTCBTbl[0];
</code></pre>
<p>除了进行free TCBs的初始化，还会进行以下两个变量的初始化</p>
<pre><code>OS_MemClr((INT8U *)&amp;OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
/*这里采取的强制转换很有意思。
OSTCBList	= (OS_TCB *)0;
</code></pre>
<p>OSTCBPrioTbl[]是用来存放对应的下标为优先级的任务的TCB指针，若该对应下标的任务已经被创建才会有相应的TCB指针，否则保持初始化的空值。这个表的作用是为了快速找个某一优先级对应的任务的任务指针。</p>
<p>OSTCBList就是指向任务块链表的头指针，这里面的任务包括当前所有存在的任务，就绪的，未就绪的。</p>
<h3 id="5os_initeventlist">5.OS_InitEventList()</h3>
<p>事件控制块链表的初始化，这个属于扩展的功能，与任务之间的通信相关，所以就先不讨论了，等到任务通信这个模块再进行讨论。</p>
<h2 id="三任务的创建">三.任务的创建</h2>
<h3 id="1任务函数的格式">1.任务函数的格式</h3>
<p>在ucosii中任务的形式如下：</p>
<p>实际上任务就是一个不带返回值具有死循环的函数</p>
<pre><code class="language-c">void task(void *p_arg)
{		
		while(1)
		{

		}
		
}
</code></pre>
<h3 id="2ostaskcreate">2.OSTaskCreate(）</h3>
<p>任务的创建</p>
<pre><code class="language-c">INT8U  OSTaskCreate (void   (*task)(void *p_arg),
                     void    *p_arg,
                     OS_STK  *ptos,
                     INT8U    prio)
    //任务函数
    //任务所需的参数
    //堆栈
    //优先级
</code></pre>
<ul>
<li>
<p>确保未在ISR中进行任务的创建。利用中断的嵌套层数OSIntNesting进行判断</p>
</li>
<li>
<p>对相应优先级的任务对应的OSTCBPrioTbl[prio]进行占位。由于ucosii仅支持的同一优先级的任务仅有一个，所以需先判断正在创建的任务的优先级是否已经被占用了。</p>
</li>
<li>
<p>堆栈初始化</p>
<pre><code class="language-c"> OS_STK *OSTaskStkInit (void (*task)(void *p_arg), 
 void *p_arg, OS_STK *ptos, INT16U opt)
</code></pre>
<p>所谓堆栈的初始化实际上就是对相关的寄存器进行模拟压栈的操作，并返回压栈后的栈顶指针。模拟压栈就是模仿任务切换时对相应寄存器进行的压栈操作。在这里主要的功能是确定堆栈栈顶指针的位置，同时把设置LR寄存器的值，并保存任务函数的地址，以及任务函数的参数指针。而其余的几个寄存器的值在这时是无意义的，不必关心其模拟压栈的内容。</p>
</li>
<li>
<p>TCB初始化</p>
<p>OS_TCBInit()</p>
<ul>
<li>从OSTCBFreeList获得一个空的tcb</li>
<li>把任务的相关信息放到这个空的tcb的相应位置</li>
<li>把被占位的OSTCBPrioTbl[]进行赋值，ptcb</li>
<li>把该tcb链入TCB链表</li>
<li>把该任务放进就绪队列</li>
</ul>
</li>
<li>
<p>是否开始调度</p>
<p>在这里还不会进行调度，因为调度的条件是OSRunning == OS_TRUE，而现在OSRunning == OS_FALSE。</p>
<p>OS_Sched()     //Schedule only if all ISRs done</p>
<ul>
<li>OS_SchedNew()  获得当前就绪队列中的最高的优先级，采用优先级位图的方式直接获得</li>
<li>判断当前执行的任务是否为最高优先级的任务，若不是则调用OS_TASK_SW()则进行任务切换。</li>
</ul>
</li>
</ul>
<h2 id="四操作系统的启动">四.操作系统的启动</h2>
<p>OSStart()</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="ucosii运行流程">ucosii运行流程</h1>
<h2 id="一系统时钟中断额初始化">一.系统时钟中断额初始化</h2>
<p>SysTick中断初始化，在轮转调度过程中，需要一个时钟中断来进行任务的切换。时钟中断的频率就是系统的心跳，也被称为时基，它决定了操作系统进行任务切换的频率。</p>
<h2 id="二操作系统初始化">二.操作系统初始化</h2>
<h3 id="1osinithookbegin">1.OSInitHookBegin()</h3>
<p>主要进行一些扩展功能的初始化</p>
<h3 id="2os_initmisc">2.OS_InitMisc()</h3>
<p>主要作用：进行杂项变量的初始化，主要有以下内容需要被初始化</p>
<pre><code class="language-c">OSIntNesting    		中断嵌套层数清零
OSLockNesting			
OSTaskCtr				任务计数清零
OSRunning				操作系统运行标志位清零
OSCtxSwCtr				任务切换计数清零
OSIdleCtr				
</code></pre>
<h3 id="3os_initrdylist">3.OS_InitRdyList()</h3>
<p>就绪队列的初始化，所谓就绪队列指由就绪任务构成的队列，但是这里实际上初始化的并不是队列，就绪队列里面保存的也不是就绪任务的TCB。</p>
<pre><code class="language-c">//以下是就绪队列实现的定义和初始化的代码
typedef unsigned char INT8U;

typedef  INT8U    OS_PRIO;

OS_EXT  OS_PRIO           OSRdyTbl[OS_RDY_TBL_SIZE];

for (i = 0u; i &lt; OS_RDY_TBL_SIZE; i++) {
        OSRdyTbl[i] = 0u;
    }

</code></pre>
<p>从这里可以看出，就绪队列的本质是一个8位无符号整型数组，仅仅保存的是一个整型，而不是TCB或者TCB指针。</p>
<p>为什么仅仅保存整型就可以表示就绪队列呢？这个以后再说。</p>
<p>除了初始化就绪队列，还初始化了两个与优先级相关的变量以及两个和任务TCB相关的量。<br>
OSPrioCur	   		保存当前任务的优先级<br>
OSPrioHighRdy      保存当前就绪队列优先级最高的任务的优先级<br>
OSTCBCur 	          保存当前任务的TCB指针<br>
OSTCBHighRdy      保存当前就绪队列中最高优先级任务的TCB指针</p>
<h3 id="4os_inittcblist">4.OS_InitTCBList ()</h3>
<p>初始化TCB链表，这里主要强调的链表，主要是把在头文件里声明的</p>
<p>OS_TCB	OSTCBTbl[OS_MAX_TASKS + OS_N_SYS_TASKS];		这个TCB数组拆开然后用指针将其连接起来。</p>
<pre><code class="language-c">for (ix = 0u; ix &lt; (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
        ix_next =  ix + 1u;
        ptcb1   = &amp;OSTCBTbl[ix];
        ptcb2   = &amp;OSTCBTbl[ix_next];
        ptcb1-&gt;OSTCBNext = ptcb2;
}

ptcb1                   = &amp;OSTCBTbl[ix];
ptcb1-&gt;OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
OSTCBFreeList           = &amp;OSTCBTbl[0];
</code></pre>
<p>除了进行free TCBs的初始化，还会进行以下两个变量的初始化</p>
<pre><code>OS_MemClr((INT8U *)&amp;OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
/*这里采取的强制转换很有意思。
OSTCBList	= (OS_TCB *)0;
</code></pre>
<p>OSTCBPrioTbl[]是用来存放对应的下标为优先级的任务的TCB指针，若该对应下标的任务已经被创建才会有相应的TCB指针，否则保持初始化的空值。这个表的作用是为了快速找个某一优先级对应的任务的任务指针。</p>
<p>OSTCBList就是指向任务块链表的头指针，这里面的任务包括当前所有存在的任务，就绪的，未就绪的。</p>
<h3 id="5os_initeventlist">5.OS_InitEventList()</h3>
<p>事件控制块链表的初始化，这个属于扩展的功能，与任务之间的通信相关，所以就先不讨论了，等到任务通信这个模块再进行讨论。</p>
<h2 id="三任务的创建">三.任务的创建</h2>
<h3 id="1任务函数的格式">1.任务函数的格式</h3>
<p>在ucosii中任务的形式如下：</p>
<p>实际上任务就是一个不带返回值具有死循环的函数</p>
<pre><code class="language-c">void task(void *p_arg)
{		
		while(1)
		{

		}
		
}
</code></pre>
<h3 id="2ostaskcreate">2.OSTaskCreate(）</h3>
<p>任务的创建</p>
<pre><code class="language-c">INT8U  OSTaskCreate (void   (*task)(void *p_arg),
                     void    *p_arg,
                     OS_STK  *ptos,
                     INT8U    prio)
    //任务函数
    //任务所需的参数
    //堆栈
    //优先级
</code></pre>
<ul>
<li>
<p>确保未在ISR中进行任务的创建。利用中断的嵌套层数OSIntNesting进行判断</p>
</li>
<li>
<p>对相应优先级的任务对应的OSTCBPrioTbl[prio]进行占位。由于ucosii仅支持的同一优先级的任务仅有一个，所以需先判断正在创建的任务的优先级是否已经被占用了。</p>
</li>
<li>
<p>堆栈初始化</p>
<pre><code class="language-c"> OS_STK *OSTaskStkInit (void (*task)(void *p_arg), 
 void *p_arg, OS_STK *ptos, INT16U opt)
</code></pre>
<p>所谓堆栈的初始化实际上就是对相关的寄存器进行模拟压栈的操作，并返回压栈后的栈顶指针。模拟压栈就是模仿任务切换时对相应寄存器进行的压栈操作。在这里主要的功能是确定堆栈栈顶指针的位置，同时把设置LR寄存器的值，并保存任务函数的地址，以及任务函数的参数指针。而其余的几个寄存器的值在这时是无意义的，不必关心其模拟压栈的内容。</p>
</li>
<li>
<p>TCB初始化</p>
<p>OS_TCBInit()</p>
<ul>
<li>从OSTCBFreeList获得一个空的tcb</li>
<li>把任务的相关信息放到这个空的tcb的相应位置</li>
<li>把被占位的OSTCBPrioTbl[]进行赋值，ptcb</li>
<li>把该tcb链入TCB链表</li>
<li>把该任务放进就绪队列</li>
</ul>
</li>
<li>
<p>是否开始调度</p>
<p>在这里还不会进行调度，因为调度的条件是OSRunning == OS_TRUE，而现在OSRunning == OS_FALSE。</p>
<p>OS_Sched()     //Schedule only if all ISRs done</p>
<ul>
<li>OS_SchedNew()  获得当前就绪队列中的最高的优先级，采用优先级位图的方式直接获得</li>
<li>判断当前执行的任务是否为最高优先级的任务，若不是则调用OS_TASK_SW()则进行任务切换。</li>
</ul>
</li>
</ul>
<h2 id="四操作系统的启动">四.操作系统的启动</h2>
<p>OSStart()</p>
<!-- more -->
<h3 id="1判断osrunning-os_false">1.判断OSRunning == OS_FALSE</h3>
<h3 id="2os_schednew">2.OS_SchedNew()</h3>
<p>获得当前就绪队列中的最高的优先级，采用优先级位图的方式直接获得</p>
<h3 id="3设置ospriocurostcbhighrdyostcbcur">3.设置OSPrioCur，OSTCBHighRdy，OSTCBCur</h3>
<h3 id="4osstarthighrdy">4.OSStartHighRdy()</h3>
<p>设置PendSV的中断优先级</p>
<p>初始化PSP</p>
<p>设置OSRunning标志为1</p>
<p>开启PendSV中断。</p>
]]></content>
    </entry>
</feed>