<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yvainefire.github.io</id>
    <title>YvaineFire_block</title>
    <updated>2021-04-03T07:23:56.639Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yvainefire.github.io"/>
    <link rel="self" href="https://yvainefire.github.io/atom.xml"/>
    <subtitle>Rush Rush B</subtitle>
    <logo>https://yvainefire.github.io/images/avatar.png</logo>
    <icon>https://yvainefire.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, YvaineFire_block</rights>
    <entry>
        <title type="html"><![CDATA[C++ 函数编写]]></title>
        <id>https://yvainefire.github.io/post/c-han-shu-bian-xie/</id>
        <link href="https://yvainefire.github.io/post/c-han-shu-bian-xie/">
        </link>
        <updated>2021-04-03T07:23:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="使用带默认参数的函数">使用带默认参数的函数</h2>
<p>C++提供了带默认参数的函数。</p>
<p>eg:</p>
<pre><code class="language-c++">void function_paramt(int a, int b, int c = 1)
{
	....
	....
}
</code></pre>
<p>在函数的定义或声明中可以为其添加默认的参数，当调用这个函数的时候，如果没有第三个参数的形参，则默认等于1。否则以形参的值为准。</p>
<p>注意在使用带默认参数的函数时有两条规则：</p>
<ul>
<li>对默认参数的解析是从右往左开开始，所以从左往右第一个使用默认参数的参数其右边的所以参数都必须使用默认参数。</li>
<li>在函数的声明和定义中只能够有一个地方使用了默认参数，建议在函数声明的位置使用默认参数。</li>
</ul>
<h2 id="使用inline声明函数">使用inline声明函数</h2>
<p>为了提高函数的效率减少函数之间调用所产生的开销，可以使用inline来声明一个函数，从而使该函数内部调用的函数，在编译的时候能展开，从而减少了一个函数对另一个函数的调用。</p>
<p>inline的作用简单来说就是对函数进行展开。</p>
<p>eg:</p>
<pre><code class="language-c++">inline void il_templet(int a, int b)
{
	fun1();
	fun2();
	.......
}
</code></pre>
<p>注意：inline只是对编译器提出的一种请求，并不是强制性的。所以编译是否会执行，还需要根据编译器而定。</p>
<h2 id="函数的重载">函数的重载</h2>
<p>不同于C语言，C++可以对函数进行重载，所谓重载也就是指对一个同名的函数可以根据其参数的不同而进行区别。这里参数不同可以指参数的类型不同，参数的数量不同。</p>
<p>在调用函数的时候，根据调用时所给定的形参来选择相应的函数进行调用。</p>
<p>eg:</p>
<pre><code class="language-c++">void func_overlaoding_1();
void func_overlaoding_1(int a);
void func_overlaoding_1(string a);
void func_overlaoding_1(int a, int b);
......
</code></pre>
<p>注意：返回类型并不作为区分函数重载的依据，因为调用函数的时候，用时候并不会使用到其返回类型，这就导致了编译器不能对齐进行解析。</p>
<h2 id="模板函数">模板函数</h2>
<p>当一个几个函数函数体相似，而仅仅是函数中某个变量的数据类型不一样的时，可以使用定义一个函数模板方式，来减少定义多个类似的函数。</p>
<p>定义一个函数模板，最开始以关键字template开头，然后用&lt; &gt;包含多个标识符。</p>
<p>eg:</p>
<pre><code class="language-c++">template &lt;typename elemType&gt;
void template_function(int a, vector&lt;elemType&gt; &amp;vec)
{
.......
}
</code></pre>
<p>使用一个函数模板，先定义模板中未定义的参数的类型</p>
<p>eg:</p>
<pre><code class="language-c++">vector&lt;int&gt; ivec;
template_function(a, ivec);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ point & reference]]></title>
        <id>https://yvainefire.github.io/post/point-and-reference/</id>
        <link href="https://yvainefire.github.io/post/point-and-reference/">
        </link>
        <updated>2021-04-02T13:33:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="reference">reference</h2>
<p>引用类型：通过将声明符写成&amp;d的形式来定义引用声明，d是定义的变量的名称。</p>
<p>eg:</p>
<pre><code class="language-c++">int ival = 1024;
int &amp;refVal = ival;
</code></pre>
<p>引用类型不是对初始对象的拷贝，而是将初值对象与其绑定在一起。而且一旦该引用类型初始化完成，它将一直与处置对象绑定，不能更改它所绑定的引用对象。同时对绑定的所有操作等价于对初始对象的所有操作。</p>
<p>引用本身不是一个对象，所以不能定义引用的引用。</p>
<h2 id="pointer">pointer</h2>
<p>指针是指向另外一种类型的复合类型。通过将声明符写成*d的形式，其中d是变量的名。</p>
<p>eg：</p>
<pre><code class="language-c++">int *ip;
double *dp;
</code></pre>
<p>注意：指针所指向对象的类型和指针声明的类型必须保持一致。对空指针进行操作可能会出现未知的错误。</p>
<h3 id="空指针">空指针</h3>
<p>空指针是指不指向任何对象的指针</p>
<p>常见空指针的声明方法</p>
<pre><code class="language-c++">//为了避免误解，最好把*写在变量的前面而不要写在类型前面
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL;


</code></pre>
<p>注意：还有一种情况是指向动态分配的空间的地址被回收了之后的指针也是空指针。</p>
<h3 id="void">void *</h3>
<p>可以存放任意对象的地址，也就是说可以存放任意对象的指针</p>
<h3 id="函数指针">函数指针</h3>
<p>函数指针是指向函数的指针。它必须指明所指函数的返回类型及参数列表。</p>
<p>使用函数指针的方式一：</p>
<ul>
<li>
<p>先声明一个函数指针</p>
<p>eg:</p>
<pre><code class="language-c++">const vector&lt;int&gt; (*seq_ptr)(int);
</code></pre>
</li>
<li>
<p>在用一个类型与之匹配的函数对其进行初始化</p>
</li>
</ul>
<p>使用函数指针的方式二：</p>
<ul>
<li>
<p>用typedef定义函数指针</p>
<p>eg:</p>
<pre><code class="language-c++">typedef vector&lt;int&gt; (*fun_pointer)(int);
</code></pre>
</li>
<li>
<p>用定义的这个函数指针的函数名，作为一个新的类型去声明一个函数指针</p>
<p>eg:</p>
<pre><code class="language-c++">fun_pointer fp_1;
</code></pre>
</li>
<li>
<p>再用一个与之对的函数对其进行初始化</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于np.copy()是浅复制还是深复制?]]></title>
        <id>https://yvainefire.github.io/post/guan-yu-npcopyshi-qian-fu-zhi-huan-shi-shen-fu-zhi/</id>
        <link href="https://yvainefire.github.io/post/guan-yu-npcopyshi-qian-fu-zhi-huan-shi-shen-fu-zhi/">
        </link>
        <updated>2021-03-30T13:22:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id=""></h1>
<h2 id="官方文档">官方文档：</h2>
<p>Note that np.copy is a shallow copy and will not copy object elements within arrays. This is mainly important for arrays containing Python objects. The new array will contain the same object which may lead to surprises if that object can be modified (is mutable)</p>
<p>但是如果复制的对象不是object elements，则可以看作是deepcopy，最安全的方法还是使用copy.deepcopy()。</p>
<h2 id="eg">eg:</h2>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/pytest.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++杂项知识]]></title>
        <id>https://yvainefire.github.io/post/cza-xiang-zhi-shi/</id>
        <link href="https://yvainefire.github.io/post/cza-xiang-zhi-shi/">
        </link>
        <updated>2021-03-08T13:51:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1namespace">1.namespace</h2>
<p>namespace(命名空间)：是一种将库名称封装起来的方法。避免发生命名冲突。所谓命名冲突是指，应用程序的两个不同的实体有相同的名称。</p>
<h3 id="使用namespace来解决命名冲突的问题">使用namespace来解决命名冲突的问题</h3>
<pre><code class="language-c">using namesapce 命名空间名;
</code></pre>
<p>这样会使后续的代码将使用指定的命名空间中的名称。</p>
<p>一般使用标准库的命名空间：std</p>
<h3 id="自定义命名空间的方式">自定义命名空间的方式</h3>
<p>namespace 命名空间名{</p>
<p>​		函数1...</p>
<p>​		函数2...</p>
<p>​		变量1...</p>
<p>​		变量2...</p>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++文件的读写]]></title>
        <id>https://yvainefire.github.io/post/cwen-jian-de-du-xie/</id>
        <link href="https://yvainefire.github.io/post/cwen-jian-de-du-xie/">
        </link>
        <updated>2021-03-08T13:51:12.000Z</updated>
        <content type="html"><![CDATA[<p>包含 fstream 头文件</p>
<h2 id="输出">输出</h2>
<h3 id="定义输出的文件变量">定义输出的文件变量</h3>
<p>ofstream outfile_name(&quot;文件地址&quot;);</p>
<p><strong>文件不存在时，会创建一个新的文件</strong></p>
<p>文件存在的时候，可以通过参数对其设置是在原文件尾部追加还是直接覆盖。默认为覆盖，添加如下参数变为追加</p>
<p>ofstream outfile_name(&quot;文件地址&quot;, ios_base::app);</p>
<h3 id="判断文件是否打开成功">判断文件是否打开成功</h3>
<pre><code class="language-c++">if (!out_file_name)
	文件打开失败
......
</code></pre>
<h3 id="使用文件进行输出">使用文件进行输出</h3>
<pre><code class="language-c++">outfile_name &lt;&lt; 输出内容;		
</code></pre>
<h2 id="输入">输入</h2>
<h3 id="定义输入的文件变量">定义输入的文件变量</h3>
<p>ifstream infile_name(&quot;文件地址&quot;);</p>
<h3 id="判断文件是否打开成功-2">判断文件是否打开成功</h3>
<pre><code class="language-c++">if (!in_file_name)
	文件打开失败
......
</code></pre>
<h3 id="使用文件进行输入">使用文件进行输入</h3>
<pre><code>in_flie_name &gt;&gt; 变量名
</code></pre>
<h2 id="同时输出和输入">同时输出和输入</h2>
<h3 id="定义输入输出文件">定义输入输出文件</h3>
<p>fstream in_and_out_file_name(&quot;文件地址&quot;)</p>
<h3 id="判断文件是否打开成功-3">判断文件是否打开成功</h3>
<pre><code class="language-c++">if (!in_and_out_file_name)
	文件打开失败
......
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++的一些重要的基本类型]]></title>
        <id>https://yvainefire.github.io/post/cde-yi-xie-chong-yao-de-ji-ben-lei-xing/</id>
        <link href="https://yvainefire.github.io/post/cde-yi-xie-chong-yao-de-ji-ben-lei-xing/">
        </link>
        <updated>2021-03-08T13:50:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1string">1.string</h2>
<h3 id="string的定义">string的定义</h3>
<p>string string_name;</p>
<p>是C++标准库提供的类型，需要包含string库</p>
<h3 id="string的初始化">string的初始化</h3>
<p>string_name = &quot;字符串&quot;</p>
<h2 id="2array">2.Array</h2>
<h3 id="数组的定义">数组的定义</h3>
<p>类型 数组名[数组的大小]</p>
<p>注意：数组的大小必须是一个常量表达式，在编译时就能确定的表达式。</p>
<p><strong>不需要特定的头文件</strong></p>
<h3 id="数组的初始化">数组的初始化</h3>
<ul>
<li>
<p>采用循环的方式对数组的每个元素进行初始化</p>
<pre><code class="language-c++">for....
	array_test[i] = ...
</code></pre>
</li>
<li>
<p>在定义的时候，采用初始化列表的形式进行初始化</p>
<pre><code class="language-c++">int array_test[5]={1,2,3,4,5};
</code></pre>
</li>
</ul>
<h2 id="3vector">3.Vector</h2>
<h3 id="vector的定义">Vector的定义</h3>
<p>Vector&lt;类型&gt;	Vector名(Vector的大小)</p>
<p>注意：Vector的大小不需要是一个常量表达式</p>
<p><strong>需要一个特定的头文件 vector</strong></p>
<h3 id="vector的初始化">Vector的初始化</h3>
<ul>
<li>
<p>采用循环的方式对Vector进行初始化</p>
<pre><code class="language-c++">for....
	Vector_test[i] = ...
</code></pre>
</li>
<li>
<p>采用数组对Vector进行初始化</p>
<pre><code class="language-c++">vector&lt;int&gt; vector_test(array_test,array_test+size_of_array)
</code></pre>
<p><strong>注意不能使用初始化列表对齐进行初始化</strong></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ C++的输入输出]]></title>
        <id>https://yvainefire.github.io/post/cde-shu-ru-shu-chu/</id>
        <link href="https://yvainefire.github.io/post/cde-shu-ru-shu-chu/">
        </link>
        <updated>2021-03-08T13:50:03.000Z</updated>
        <content type="html"><![CDATA[<p>输出/输出库：iostream</p>
<h2 id="1输出">1.输出</h2>
<p>cout：将信息写到用户的终端中</p>
<p>格式：</p>
<ul>
<li>cout &lt;&lt; &quot;输出内容1&quot;;</li>
<li>cout &lt;&lt; &quot;输出内容1&quot; &lt;&lt;  &quot;输出内容2&quot; ......;</li>
<li>cout &lt;&lt; 变量;</li>
</ul>
<h2 id="2输入">2.输入</h2>
<p>cin：读取用户在终端上的内容</p>
<p>格式：</p>
<ul>
<li>cin &gt;&gt; user_name;</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python的import]]></title>
        <id>https://yvainefire.github.io/post/python-de-import/</id>
        <link href="https://yvainefire.github.io/post/python-de-import/">
        </link>
        <updated>2020-10-23T08:22:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="几个基本的概念">几个基本的概念</h2>
<p>模块：一个.py文件就是一个模块。一个模块中可以有函数，类，变量。</p>
<p>包：一个包有一个子包或者一些模块组成。</p>
<p><strong><strong>init</strong></strong>.py: 暗示自己是一个包，一个包的结构</p>
<pre><code>sample_package / 
├──的__init__.py 
├──sample_module.py 
└──sample_module_import.py
	sample_package_son / 
	├──的__init__.py 
	├──son_sample_module.py 
	└──son_sample_module_import.py
</code></pre>
<h2 id="import的是什么">import的是什么</h2>
<p>引入的是包，引入的是包中的模块，引入的是模块中的方法</p>
<h2 id="import的内容从哪去找">import的内容从哪去找</h2>
<ul>
<li>
<p>sys.path目录下，sys.path也就是python的系统环境参数，该目录下具有一些系统自带的包，以及手动导入的包。不包含自己写的.py构成的模块。</p>
</li>
<li>
<p>当前运行的.py目录</p>
</li>
</ul>
<h2 id="几种import方式">几种import方式</h2>
<h3 id="import-moudle">import [moudle]</h3>
<p>引入整个包，但是直接使用import来引用当前目录下的模块（这里是实际上也是相对引用）可能会报错。因为虽然import会去sys.path目录或者运行文件所在的目录下去寻找，但是因为pycharm不会将当前文件目录自动加入自己的sourse_path。右键make_directory as--&gt;Sources Root将当前工作的文件夹加入source_path就可以了。</p>
<p>同时还需要注意在使用该模块中的方法的使，需要先给出这个moudle名。</p>
<p>eg:</p>
<pre><code class="language-python">#假设M中有一个method()方法
import M
M.method()

</code></pre>
<h3 id="from-module-import-name1-name2">from [module] import [name1, name2,.....]</h3>
<p>引入一个包或一个模块的部分内容，可以是一个包里的几个模块，也可以是一个模块中的几种方法。</p>
<h3 id="import-module-as-new_name">import [module] as [new_name]</h3>
<p>对于莫些方法或者模块的名字太长，使用的时候可以给一个别名。</p>
<p>eg：</p>
<pre><code class="language-python">import matplotlib.pyplot as pyplot
import numpy as np
</code></pre>
<h3 id="from-module-import">from [module] import *</h3>
<p>引入一个包或者一个模块中的所有内容，不建议这样做，因为可能会出现不同的模块中有相同的方法，可能就会造成名字冲突的现象出现。</p>
<h3 id="使用进行相对引用">使用.进行相对引用</h3>
<p>以上所说的基本上都是绝对查找，主要去使用sys.path下的包。python还支持相对当前运行环境目录下的相对产找。</p>
<pre><code class="language-python">.  		表示本级目录		 from . imprt xx
..  	表示上一级目录		from .. imprt xx
...		表示上两级目录		from ... imprt xx
以此类推

</code></pre>
<p>注意只能使用from [module] import的格式</p>
<h2 id="import陷阱">import陷阱</h2>
<p>循环import：两个.py互相引用对方文件里的内容</p>
<p>解决办法：引用整个module，而不引用单个方法</p>
<p>利用执行的时候才会检查是否存在，所以先引用这个module，因为module是必然存在的，至于这个module里的内容它是不会关心的。</p>
<p>参考：https://medium.com/pyladies-taiwan/python-%E7%9A%84-import-%E9%99%B7%E9%98%B1-3538e74f57e3</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 几种C/C++的编译器]]></title>
        <id>https://yvainefire.github.io/post/ji-chong-ccde-bian-yi-qi/</id>
        <link href="https://yvainefire.github.io/post/ji-chong-ccde-bian-yi-qi/">
        </link>
        <updated>2020-10-22T09:22:22.000Z</updated>
        <content type="html"><![CDATA[<p>操作系统封住一些可向外提供的函数形成函数库，并提供相应的API，供应用软件调用。库函数通常由一个或多个链接文件的形式提供。然而对于不同的操作系统可能具有不同的库函数，特别是C标准库。</p>
<p>POSIX标准主要就是针对<a href="https://link.zhihu.com/?target=http%3A//www.unix.org/apis.html">UNIX API</a>而制订，<strong>不管函数如何包装、功能如何实现，但API按照标准约定来（比如函数变量等符号名称、数据结构、参数类型与个数、基本工具命令名称等）</strong>，Linux完全兼容POSIX标准（部分函数符合POSIX，部分函数是Linux专有，即是POSIX的超集），微软声称Windows部分兼容POSIX标准。</p>
<h2 id="gcc">GCC</h2>
<p>GCC原名GNU C Complier,开始是针对C语言进行编译，后来发展为支持多种语言编译（C++、Fortran、Pascal、Objective-C、Java、Ada、Go等），所以又叫GNU Complier Collection。</p>
<p>类Unix下的标准编译器，支持多种语言，但是不能直接在Windows下使用。</p>
<h2 id="mingw">MingW</h2>
<p>MinGw 是Minimalistic GNU for Windows的缩写，也就是Windows版的GCC。</p>
<p>实现方式：具有以W32api的头文件，把Iinux下的系统调用替换为对应的Windows下的系统调用。</p>
<h2 id="cygwin">Cygwin</h2>
<p>Cygwin是一个在windows平台上运行的类UNIX模拟环境</p>
<p>Cygwin就是在Windows中增加了一个中间层——兼容POSIX的模拟层。</p>
<p>实现方式:</p>
<ul>
<li>
<p>采用cygwin1.dll，作为实现POSIX系统调用的模拟层，可原生运行在Windows中。</p>
</li>
<li>
<p>在cygwin1.dll之上构建的大量函数库、应用程序，如libc、zlib、bash、gcc、vim、awk、sed、git等等，与UNIX/Linux几乎等同*。</p>
</li>
</ul>
<p>Cygwin将cygwin1.dll、函数库、应用程序等文件按照UNIX/Linux的目录树架构进行组织存放，如/bin、/usr、/lib、/etc、/var、/home等等都存在于Cygwin安装路径下，用户从终端登陆进Cygwin的shell后，就可以像在UNIX/Linux系统那样使用相同的命令、工具</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/1603356418(1).png" alt="" loading="lazy"></figure>
<p><strong>Cygwin 生成的程序依然有 <code>fork()</code> 这样的 Linux 系统调用，但目标库是 cygwin1。而 MingW 生成的程序，则全部使用从 KERNEL32 导出的标准 Windows 系统 API。</strong></p>
<h2 id="llvmclang">LLVM+Clang</h2>
<p>LLVM 是模块化、可重用的编译器以及工具链技术的集合。LLVM不同的就是对于不同的语言它都提供了同一种中间表示（AST）。</p>
<p>Clang是LLVM项目下的一个子项目，基于LLVM架构的C/C++/Objective-C编译器前端</p>
<h2 id="msvc系列">MSVC系列</h2>
<p>微软自己写的编译器，与VS配套使用。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Windows_library_files%22%20%5Cl%20%22MSVCRT.DLL%2C_MSVCP*.DLL_and_CRTDLL.DLL">Microsoft C run-time library</a>(MSVCRT.DLL)，由微软随Windows发布，给Visual C++编辑器链接使用的</p>
<h2 id="嵌入式系统编译器">嵌入式系统编译器</h2>
<p>MDKzhe</p>
<p><a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/UClibc">μClibc</a>等，功能经过适度裁剪的C标准库，主要用在嵌入式系统</p>
<p>参考：https://zhuanlan.zhihu.com/p/57258281</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Ucosii的任务调度和优先级位图法]]></title>
        <id>https://yvainefire.github.io/post/ucosii-de-ren-wu-diao-du-he-you-xian-ji-wei-tu-fa/</id>
        <link href="https://yvainefire.github.io/post/ucosii-de-ren-wu-diao-du-he-you-xian-ji-wei-tu-fa/">
        </link>
        <updated>2020-08-25T13:13:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id=""></h1>
<h2 id="一osrdygrp和osrdytbl">一.OSRdyGrp和OSRdyTbl</h2>
<p>OS_EXT	INT8U	OSRdyGrp;</p>
<p>OS_EXT	INT8U	OSRdyTbl[OS_LOWESET_PRIO/8+1];</p>
<ol>
<li>
<p>可以看出里OSRdyGrp是一个8位的整型</p>
<p>将其表示为2进制，则可用每一位表示1个组的状态，即1或0，为1的实时表示这个组中至少有一个优先级有就绪任务，为0则表示没有。</p>
<p>实际上也可以把OSRdyGrp的每一位想成一个8进制数的第二位，即可能是0-7的任意一位。</p>
</li>
<li>
<p>OSRdyTbl[]是一个8位的整型数组，且其数组的元素的个数为除8再加1。</p>
<p>除8与8位整型对应，同样用一个8位的整型的2进制数来表示除以8这8个数，相当于压缩了。</p>
<p>每一个整型8位2进制数，其中为1的位表示当前位的优先级有就绪的任务。</p>
<p>也可以把这个数组的每一个元素的每一位2进制数看作是一个8进制数的第一位。</p>
</li>
</ol>
<p>综上OSRdyGrp相当于确定了类似十进制数的十位而OSRdyTbl[]相当于确定了类似十进制数的个位。</p>
<p>我们的目标是寻找已经就绪的最高优先级。即找到OSRdyGrp中第一个出现1的位相当于这里已经确定了十位，再找到确定了十位后在OSRdyTbl[十位]中最早出现1的个位。</p>
<p>如何确定这两个最早出现的位，同时又确保时间无关性？</p>
<p>如何用for循环直接去找的话没法做到时间的无关性的。</p>
<p>这里就必须引入一个优先级判定表</p>
<h2 id="二优先级判定表">二.优先级判定表</h2>
<pre><code class="language-c">INT8U  const  OSUnMapTbl[256] = {
    0u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x00 to 0x0F                   */
    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x10 to 0x1F                   */
    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x20 to 0x2F                   */
    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x30 to 0x3F                   */
    6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x40 to 0x4F                   */
    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x50 to 0x5F                   */
    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x60 to 0x6F                   */
    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x70 to 0x7F                   */
    7u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x80 to 0x8F                   */
    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x90 to 0x9F                   */
    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xA0 to 0xAF                   */
    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xB0 to 0xBF                   */
    6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xC0 to 0xCF                   */
    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xD0 to 0xDF                   */
    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xE0 to 0xEF                   */
    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u  /* 0xF0 to 0xFF                   */
};
</code></pre>
<p>数组共有256个元素其下标为0-255，表示一个8位2进制数所能表示的值。数组的每一个元素表示这个下标对应的10进制数的2进制表示形式中第一个出现1的位所在的位数。比如说下标为16的数，其二进制的表示形式为10000，所以最先出现1的位数是第4位，从上表中可以找到下标为16即0X10对于的元素为1u。</p>
<p>所以根据这个优先级表，可以在时间无关的限制下找到OSRdyGrp和OSRdyTbl[]最早出现1的位的位值。也就找到了当前最高优先级的值。</p>
<p>下一个问题就是如何把这两个值拼接为一个10进制数，因为优先级使用的时候都是以10进制数的形式去找到对应优先级的指针，即当前到调度的任务的指针。</p>
<p>前面已经说明可以将其看作一个8进制数，所以就是相当于把一个分别知道第一位A和第二位B的且只有两位的8进制数转换为一个10进制数。</p>
<p>A*8+B 使用位运算 = A &lt;&lt; 3 + B</p>
<p>转换为程序中的变量进行表示：</p>
<p>y = OSUnMapTbl[OSRdyGrp] &lt;&lt; 3</p>
<p>x = OSUnMapTbl[OSRdyTbl[y]]</p>
<p>优先级 = x + y</p>
<h2 id="三结合ucosii的运用优先级位图">三.结合ucosii的运用优先级位图</h2>
<p>1.把一个新创建的任务放入就绪队列</p>
<p>放入就绪队列的意义就是指把OSRdyTbl[]这个8位2进制整型数组的对应位置1，以表示该优先级有对应的任务就绪。</p>
<p>所以问题就是把这个任务原本具有的10进制的优先级在OSRdyTbl[]上体现出来，同时为了找到OSRdyTbl[]上的行，还必须使用OSRdyGrp，所以也需要更新OSRdyGrp。</p>
<p>OSRdyTbl[]这个数组本身就可以理解为一个2位的8进制数。实际上就是把任务的10进制数转换为2位的8进制数，并把8进制数的第一位和第二位分开，第二位用于确定行数，第一位用于确定列数。</p>
<p>在TCB的结构中有4个变量用来存储这两位,并在OSTCBInit()这个函数中为这几个变量赋值</p>
<pre><code class="language-c">ptcb-&gt;OSTCBY = (INT8U) (prio &gt;&gt; 3);//取第二组3位，分离8进制第二位
ptcb-&gt;OSTCBBitY = OSMapTbl[ptcb-&gt;OSTCBY];
ptcb-&gt;OSTCBX = (INT8U) (prio &amp; 0x07);//取第一组3位，分离8进制第一位
ptcb-&gt;OSTCBBitX = OSMapTbl[ptcb-&gt;OSTCBX];
</code></pre>
<p>bit是为了将这个分离出来的数用掩码表示即用8位二进制数每一位有且仅有1位为1的时候表示0-7（即7表示为10000000），为了方便对OSRdyGrp和OSRdyTbl[]直接使用位运算进行更新。</p>
<p>更新OSRdyGrp和OSRdyTbl[]的操作</p>
<pre><code class="language-c">OSRdyGrp |= ptcb-&gt;OSTCBBitY;
OSRdyTBl[ptcb-&gt;OSTCBY] |= ptcb-&gt;OSTCBBitX;
</code></pre>
<p>2.找到当前最高优先级的任务</p>
<p>所谓优先级最高的任务的调度，也就是要找到最高优先级，因为在ucosii中为了设计的简单和确保实时性，所以一个优先级只有有一个任务，即不可能有同样优先级的任务。所以找到了当前的最高优先级就找到了其对应的任务。</p>
<pre><code class="language-c">OS_SchedNew(){
	INT8U y;
	y = OSUnMapTbl[OSRdyGrp]; //找到行
	OSPrioHighRdy = y &lt;&lt; 8 + OSUnMapTbl[OSRdyGrp[y]];	

}
</code></pre>
<h2 id="四任务调度">四.任务调度</h2>
<p>任务调度的函数：</p>
<pre><code class="language-c">void  OS_Sched (void)
{
#if OS_CRITICAL_METHOD == 3u              /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0u;
#endif


    OS_ENTER_CRITICAL();
    if (OSIntNesting == 0u) {             /* Schedule only if all ISRs done and ...       */
        if (OSLockNesting == 0u) {                     /* ... scheduler is not locked     */
            OS_SchedNew();
            OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy   */
#if OS_TASK_PROFILE_EN &gt; 0u
                OSTCBHighRdy-&gt;OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task */
#endif
                OSCtxSwCtr++;             			/* Increment context switch counter   */
                OS_TASK_SW();                          /* Perform a context switch        */
            }
        }
    }
    OS_EXIT_CRITICAL();
}
</code></pre>
<p>任务调度不能发生在中断中</p>
<p>任务调度需要调度锁是开启状态</p>
<p>任务是否需要切换，最高优先级是否改变优先级</p>
<p>找到当前最高优先级的任务OS_SchedNew();</p>
<p>任务调度过程发生在临界区中</p>
<h2 id="五上下文的切换">五.上下文的切换</h2>
<p>上下文切换的目的就是CPU需要切换到另一个任务是需要保存当前任务的运行状态并恢复另一个任务的运行状态。</p>
<p>上下文切换分为：</p>
<ul>
<li>
<p>主动上下文切换：任务执行过程中自动挂起自己OSTaskSuspend()</p>
</li>
<li>
<p>被动上下文切换：又叫中断触发任务切换，是指在由于中断引起抢占当时正在执行的任务，保存正在执行的任务的运行信息并且在中断响应完之后重新进行调度，恢复当前优先级最高的任务引起的上文的切换。</p>
</li>
</ul>
<p>1.主动上下文切换</p>
<ul>
<li>
<p>保存当前正在执行的任务的运行信息</p>
<p>保存信息的顺序：</p>
<p>PC,LR,R12-R0,CPSR</p>
<p>注意当调用这个函数的时候，会自动把当前执行指令的地址PC下一条指令保存到LR，PC转为这个函数第一条指令的地址，所以保存要下一条指令的值即PC的值，只能通过保存链接寄存器LR的值来达到这一目的。</p>
<p>再保存LR这里实际上和第一个保存的PC的值是一样的，但是为什么要保持两次呢，因为只是在这种情况下这两个值是一样得。如果涉及到处理器运行状态的改变就可能不同了。</p>
<p>对于CPSR的处理，也要注意，只有MRS指令可以读CPSR，所以要先用MRS指令将其读到一个寄存器中，再将其放入 堆栈中。</p>
<pre><code class="language-c">
</code></pre>
</li>
<li>
<p>修改要运行的任务指针为最高优先级任务的指针</p>
<p>OSTCBCur = OSTCBHighRdy</p>
<pre><code class="language-c">
</code></pre>
</li>
<li>
<p>修改当前任务的优先级为最高优先级</p>
<p>OSPrioCur = OSPrioHighRdy</p>
<pre><code class="language-c">
</code></pre>
</li>
<li>
<p>修改当前的堆栈指针SP为当前最高优先级的任务的堆栈指针</p>
<p>OSPrioHighRdy这个结构体的第一个就是它的堆栈指针，所以也就是它的地址</p>
<p>SP = OSPrioHighRdy这个地址的值</p>
<pre><code class="language-c">
</code></pre>
</li>
<li>
<p>恢复当前最高优先级的任务的运行信息</p>
<p>注意出栈的顺序与入栈的顺寻相反</p>
<p>出栈的时候LR用于更新PC,同时还要恢复CPSR的值，即^符号</p>
<pre><code class="language-c">
</code></pre>
</li>
</ul>
]]></content>
    </entry>
</feed>