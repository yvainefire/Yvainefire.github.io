<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yvainefire.github.io</id>
    <title>YvaineFire_block</title>
    <updated>2020-07-31T10:10:40.219Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yvainefire.github.io"/>
    <link rel="self" href="https://yvainefire.github.io/atom.xml"/>
    <subtitle>Rush Rush</subtitle>
    <logo>https://yvainefire.github.io/images/avatar.png</logo>
    <icon>https://yvainefire.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, YvaineFire_block</rights>
    <entry>
        <title type="html"><![CDATA[Linux套接字编程]]></title>
        <id>https://yvainefire.github.io/post/linux-tao-jie-zi-bian-cheng/</id>
        <link href="https://yvainefire.github.io/post/linux-tao-jie-zi-bian-cheng/">
        </link>
        <updated>2020-07-30T08:16:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一posix标准">一.POSIX标准</h2>
<p>POSIX表示可移植操作系统接口，是IEEE为各种UNIX操作系统上运行的软件定义的一系列API标准的总称。</p>
<h2 id="二socket基本概念">二.Socket基本概念</h2>
<ol>
<li>
<p>套接字：协议操作的接口，而非协议本身。应用层通过这个接口使用传输层提供的服务，进行接收和发送数据包。</p>
</li>
<li>
<p>主动套接字和被动套接字</p>
<p>主动套接字：发起连接的套接字</p>
<p>被动套接字：等待传入的套接字</p>
</li>
<li>
<p>套接字的基本类型</p>
<p>SOCKET_DGRAM：双向不可靠数据流</p>
<p>SOCKET_STREAM：双向可靠数据流</p>
<p>SOCKET_RAW：低级协议或为物联网络提供的套接字</p>
</li>
</ol>
<h2 id="三套接字的地址结构类型">三.套接字的地址结构类型</h2>
<ol>
<li>
<p>两种套接字</p>
<p>​	   a.通用套接字</p>
<pre><code class="language-c">struct sockaddr{
    unsigned short sa_family;/*地址族*/
    char sa_data[14];
};
</code></pre>
<p>​		b.ipv4套接字</p>
<pre><code class="language-c">struct sockaddr_in{    
    short int sin_family;/*地址族*/
    unsigned short int sin_port;/*端口号*/
    struct in_addr sin_addr;/*IP地址*/
    unsigned char sin_zero[8];/*零数据*/
}；
</code></pre>
<p>​		c.ipv6套接字</p>
<pre><code class="language-c">struct sockaddr_in6
</code></pre>
<p>地址族：决定了决定了套接字的种类</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/family.png" alt="" loading="lazy"></figure>
<p>通用套接字和特殊套接字之间可以进行相互的转换，这两种表现形式实际上是等价的。socketaddr_in用于用户设置的地址信息，sockaddr则用于作为bind,connet,recfvfrom等函数的参数。</p>
</li>
<li>
<p>地址转换函数</p>
<pre><code class="language-c">int inet_pton(int family,const char *src,void *dst);

const char *inet_ntop(int family,const void *src,char *dst,size_t cnt);
</code></pre>
<p>dst是指向struct in_addr或struct in6_addr 的指针，必须事先分配空间src是指向点分10进制的字符串指针</p>
</li>
</ol>
<h2 id="四几个重要的函数">四.几个重要的函数</h2>
<h3 id="1socket函数">1.socket函数</h3>
<p>int socket(int family,int type,int protocol)</p>
<p>作用：创建一个新的套接字</p>
<p>参数：</p>
<ul>
<li>
<p>family：网络协议族（IPV4,IPV6,UNIX）</p>
</li>
<li>
<p>type：协议类型 (字节流，数据报，有序分组套接字，原始套接字）</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/type.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>protocol：特定的协议类型（TCP,UDP,SCTP）</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/protocol.png" alt="" loading="lazy"></figure>
</li>
<li>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/relation.png" alt="" loading="lazy"></figure>
<p>UDP是数据报套接字</p>
<p>TCP是字节流套接字</p>
</li>
</ul>
<p>返回值：返回值为非负则说明申请一个套接字成功，出错返回-1</p>
<h3 id="2bind函数">2.bind函数</h3>
<p>int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);</p>
<p>作用：把套接字绑定在相应的ip和端口</p>
<p>参数：</p>
<ul>
<li>sockfd：开始创建的套接字描述符</li>
<li>myaddr：指向特定协议的地址结构指针，指本地地址和端口号</li>
<li>addrlen：地址长度</li>
</ul>
<p>对于客户机而言：绑定一个特定的IP就相当于为该套接字发送的IP数据报指定了源IP地址，但是这个IP应该是属于这个主机的某个端口。如果没有调用bind函数进行绑定，则内核会为相应的套接字选择一个临时的端口，常用于客户机上。</p>
<p>对于服务器而言：绑定一个特定的IP就限定了该套接字只接收那些客户机的IP数据报。</p>
<p><strong>绑定的具体含义</strong>：绑定涉及到三个对象，套接字，地址和端口。其中套接字是捆绑的主体，地址和端口是绑定在套接字上的客体。</p>
<p>返回值：成功返回0，出错返回-1</p>
<h3 id="3connect函数">3.connect函数</h3>
<p>int connect(int sockfd,const struct sockaddr *servaddr,socklen_t addrlen)</p>
<p>作用：客户机用connect函数来建立与TCP服务器的连接。</p>
<p>参数：</p>
<ul>
<li>sockfd：<strong>创建的套接字，这里可以是已绑定的，也可以是还未绑定的，未绑定的套接字，内核会自动为它进行分配相应的ip和端口号。</strong></li>
<li>servaddr：指向要建立连接的服务器的ip地址和端口号，这两个信息一般来说是周知的。</li>
<li>addrlen：地址的长度。</li>
</ul>
<p>返回值：成功返回0，出错返回-1</p>
<p>注意：当循环调用connect并尝试知道有一个成功的连接时，在每次connect失败后都必须closed掉当前的套接字描述符并重新调用socket。</p>
<h3 id="4listen函数">4.listen函数</h3>
<p>int listen (int sockfd,int backlog);</p>
<p>作用：把为建立连接的套接字转化为一个被动套接字，指示内核应接受指向该套接字的连接请求。在接收到客户机的SYN时在未连接的队列中创建一个新的单元，在三次握手完成后就将未连接的队列连接到已连接的队列，并返回1表示连接成功。listen函数总的来说就是做监听作用。</p>
<p>参数：</p>
<ul>
<li>sockfd：指示套接字的描述符</li>
<li>backlog：指定监听连接的数量，已连接的队列和未连接的队列之和不超过backlog的值。</li>
</ul>
<p>返回值：</p>
<p>成功返回0，出错返回-1</p>
<h3 id="5accept函数">5.accept函数</h3>
<p>int accept(int sockfd,struct sockaddr *<em>cliaddr,socklen_t</em> *addrlen);</p>
<p>作用：成功返回后，系统从完成队列中取出socket，为每个连接创建一个新的连接套接字，服务器只对新的连接使用该套接字，**原来的监听套接字仍然保留用作其它的连接请求。**其返回值是内核自动生成的一个全新的描述符。<strong>一个服务器通常只有一个监听套接字</strong>，内核为服务器的每个进程创建一个新的套接字用以保持连接，在连接结束后就会自动关闭这个连接套接字，而监听套接字在服务器的整个生命周期一直存在。</p>
<p>参数：</p>
<ul>
<li>
<p>sockfd：监听套接字的描述符，用于TCP协议</p>
</li>
<li>
<p>cliaddr：这个sockadd指针会在accept函数里面进行设置</p>
</li>
<li>
<p>addrlen：这个长度指针也会在accept函数里面进行设置</p>
</li>
</ul>
<p>返回值：</p>
<p>若成功则描述结果为非负也就是内核为接受的客服连接创建的一个已连接套接字，出错则为-1</p>
<p>关于accept函数listen函数及其维护的两个队列的相关说明</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/%E9%98%9F%E5%88%97.jpg" alt="" loading="lazy"></figure>
<p>TCP转换图：</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="" loading="lazy"></figure>
<p>在状态转换图中并未出现把未连接的套接字转换为被动套接字这个过程。</p>
<p>三次握手示意图：</p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="" loading="lazy"></figure>
<p>三次握手的第一个SYN到达时，服务器为其分配缓存和等资源，然后回发SYN，随机生成的开始序号以及ACK并等待客户端的ACK，在客户端的ACK到来后表示三路握手完成。</p>
<p>具体说明：</p>
<p>用socket创建套接字后，它是一个未连接套接字这里创建的也就是用于监听的套接字，在主动调用listen函数后就把创建的这个套接字做监听使用也就是监听套接字，也就是前面所说的把一个未连接的套接字转换为了被动套接字，所以监听套接字实际上在这个时候就等于被动套接字。在三次握手的客户端的SYN到达时，就会把这个被动套接字（监听套接字）的信息自动复制（内核自动完成）一份到为完成的队列，然后监听套接字再去监听其它的连接，这个未完成的套接字就继续做三次握手剩下的内容。在完成三次握手后就把这一项从未完成队列转移到完成队列。</p>
<h3 id="6close函数">6.close函数</h3>
<p>int close(int sockfd)</p>
<p>作用：默认行为是关闭该套接字的，然后返回调用进程。</p>
<p>参数：</p>
<ul>
<li>套接字的描述符</li>
</ul>
<p>返回值：</p>
<p>若成功则返回0，出错返回-1</p>
<h3 id="7recv函数">7.recv函数</h3>
<p>ssize_t recv(int sockfd,void *buf,size_t len,int flags)</p>
<p>作用：从TCP接收数据，返回实际的数据长度，这里的sockfd里面包含了接收的数据的IP地址。如果只有一个进程使用，立即终止连接并撤销该套接字，如果多个进程共享该套接字，将引用数减一，如果引用数降到零，则撤销它。</p>
<p>参数：</p>
<ul>
<li>
<p>sockfd：套接字描述符</p>
</li>
<li>
<p>buf：接收数据的存放缓存，指向内存的指针</p>
</li>
<li>
<p>len：接收的数据的长度</p>
</li>
<li>
<p>flags：一般为0</p>
</li>
</ul>
<p>返回值：若成功则返回读的字数，出错返回-1</p>
<h3 id="8recvfrom函数">8.recvfrom函数</h3>
<p>ssize_t recvfrom(int sockfd,void *<em>buf,size_t len,int flags,struct sockaddr</em> *src_addr,socklen_t *addrlen)</p>
<p>作用：在UDP连接上发送数据，成功就返回数据的长度，由于UDP是为建立连接的，所以事先不知道数据是从哪发来的，所以这里需要额外的参数来保存接收数据的IP和端口号。</p>
<p>参数：</p>
<ul>
<li>
<p>sockfd：套接字描述符</p>
</li>
<li>
<p>buf：接收数据的存放缓存，指向内存的指针</p>
</li>
<li>
<p>len：接收的数据的长度</p>
</li>
<li>
<p>flags：一般为0</p>
</li>
<li>
<p>src_addr：保存远端的地址（发送方，对当前而言的接收方）即IP和端口号</p>
</li>
<li>
<p>addrlen：远端的地址的长度的指针</p>
</li>
</ul>
<p>返回值：若成功则返回读的字数，出错返回-1</p>
<h3 id="9send函数">9.send函数</h3>
<p>int send(int sockfd,const void *buf,size_t len,int flags)</p>
<p>作用：在TCP连接上发送数据，成功就返回数据的长度，所以这里也不需要额外指接收数据的IP和端口号，因为套接字描述符里面有绑定。</p>
<p>参数：</p>
<ul>
<li>
<p>sockfd：套接字描述符</p>
</li>
<li>
<p>buf：发送缓存</p>
</li>
<li>
<p>len：发送数据的长度</p>
</li>
<li>
<p>flags：一般为0</p>
</li>
</ul>
<p>返回值：若成功则返回写的字数，出错返回-1</p>
<h3 id="10sendto函数">10.sendto函数</h3>
<p>int sendto(int  sockfd,const void *<em>buf,size_t len,int flags,const struct sockaddr</em> *dest_addr,socklen_t addrlen)</p>
<p>作用：在UDP连接上发送数据，成功就返回数据的长度。因为UDP套接字里没有绑定发送的IP地址和端口号，所以这里需要额外指接收数据的IP和端口号。</p>
<p>参数：</p>
<ul>
<li>
<p>sockfd：套接字描述符</p>
</li>
<li>
<p>buf：发送缓存</p>
</li>
<li>
<p>len：发送数据的长度</p>
</li>
<li>
<p>flags：一般为0</p>
</li>
<li>
<p>dest_addr：发送的数据的地址，由前面的recform获得</p>
</li>
<li>
<p>addrlen：远端的地址的长度</p>
</li>
</ul>
<p>返回值：若成功则返回写的字数，出错返回-1</p>
<h2 id="五循环服务器udp编程">五.循环服务器UDP编程</h2>
<h3 id="1服务器端">1.服务器端</h3>
<ol>
<li>
<p>建立UDP套接字</p>
</li>
<li>
<p>绑定套接字到特定的地址（将套接字与对应的地址，端口号相关联）</p>
</li>
<li>
<p>等待并接收客户端的信息</p>
</li>
<li>
<p>处理客户端请求</p>
</li>
<li>
<p>发送信息回客户端</p>
</li>
<li>
<p>关闭套接字</p>
</li>
</ol>
<h3 id="2客户端">2.客户端</h3>
<ol>
<li>
<p>建立UDP套接字</p>
</li>
<li>
<p>发送信息给服务器</p>
</li>
<li>
<p>接收来自服务器的信息</p>
</li>
<li>
<p>关闭套接字</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多进程]]></title>
        <id>https://yvainefire.github.io/post/duo-jin-cheng/</id>
        <link href="https://yvainefire.github.io/post/duo-jin-cheng/">
        </link>
        <updated>2020-07-30T07:25:38.000Z</updated>
        <content type="html"><![CDATA[<p>#一. fork函数</p>
<h2 id="1关于fork函数">1.关于fork()函数</h2>
<p>pid_t fork(void);</p>
<p>创建一个新的进程，对于原进程而言该进程是子进程。</p>
<p>注意子进程和父进程的关系</p>
<h2 id="2关于返回值">2.关于返回值</h2>
<p>返回值有两个</p>
<p>对于子进程而言返回值为0</p>
<p>对于父进程而言，返回值是子进程的进程号</p>
<p><strong>为什么返回值会设置两个</strong>：因为对于一个父进程而言，是很难获得其子进程的进程号的，毕竟 一个父进程可能会有多个子进程。所以对于父进程而言，返回值设置其子进程的进程号，方便  父进程进行记录。而对于子进程而言，就很容易找到其父进程对应的进程号，使用getppid()函数。<br>
出错返回-1</p>
<h2 id="3关于拷贝">3.关于拷贝</h2>
<p>os会分配新的内存空间和内核数据结构给子进程</p>
<p>父进程中的部分代码，数据会拷贝到子进程中包括父进程的数据空间，堆，栈，还包括缓冲区的数据。这些拷贝的东西都是父本，所以是不会进行数据共享的，包括信号量。对于代码拷贝一定要注意：只拷贝位于fork()之后的代码，同时这里的拷贝不是真正的拷贝，只能说是代码的共享。这里特别注意循环结构，</p>
<p><strong>父子进程是相对的</strong>！！！！</p>
<p><strong>特别注意在带循环的进程创建的时候，在父进程创建子进程后，子进程拷贝的代码是for()位置当前未执行完的代码，即还需要考虑仍需执行的循环的次数。若该子进程会进行fork()创建对他而言的子进程，则在以此子进程为主进程的进程中，此子进程充当父进程。即父子进程是相对的额，是根据两进程的相对关系而言的。这里特别要注意，使用for进行fork()时一共创建的进程不是1+n个！！！</strong></p>
<p>两段代码：<br>
代码1</p>
<pre><code class="language-c">for(int i=0;i&lt;3;i++)  
{    
    if(pid=fork())    
    {      
        printf(&quot;%d\n&quot;,getpid());    
    }    
    else    
    {      
        printf(&quot;%d\n&quot;,getpid());    
    }      
}
</code></pre>
<p>代码2</p>
<pre><code class="language-c">int i=1;

  while((pid=fork()))    
  {            
      printf(&quot;pid:%d i:%d\n&quot;,getpid(),i);      
      if(i&gt;5)      
      {                  
          break;      
      }                      
      i++;        
  }    

printf(&quot;pid:%d\n&quot;,getpid());
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数指针]]></title>
        <id>https://yvainefire.github.io/post/han-shu-zhi-zhen/</id>
        <link href="https://yvainefire.github.io/post/han-shu-zhi-zhen/">
        </link>
        <updated>2020-07-30T07:07:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一函数指针和函数首地址">一.函数指针和函数首地址</h2>
<p>地址的联系</p>
<p>如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，<strong>这段存储空间的首地址称为这个函数的地址</strong>。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫<strong>作函数指针变量</strong>，简称函数指针。</p>
<h2 id="二函数指针的定义方式">二.函数指针的定义方式</h2>
<p>然而函数指针的定义和普通指针的定义事不同的。</p>
<p>函数指针的定义方式：</p>
<pre><code>函数返回值类型 (* 指针变量名) (函数参数列表);
</code></pre>
<p>例：</p>
<pre><code class="language-c"># include &lt;stdio.h&gt;
int Max(int, int);  //函数声明
int main(void){    
    int(*p)(int, int);  //定义一个函数指针    
    int a, b, c;    
    p = Max;  //把函数Max赋给指针变量p, 使p指向Max函数    
    
    printf(&quot;please enter a and b:&quot;);    
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);    
    c = (*p)(a, b);  //通过函数指针调用Max函数    
    printf(&quot;a = %d\nb = %d\nmax = %d\n&quot;, a, b, c);   
    
    return 0;
}
int Max(int x, int y)  //定义Max函数
{    
    int z;    
    if (x &gt; y) {        
        z = x;    
    }else 
    {        
        z = y;    
    }    
    return z;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对齐]]></title>
        <id>https://yvainefire.github.io/post/dui-qi/</id>
        <link href="https://yvainefire.github.io/post/dui-qi/">
        </link>
        <updated>2020-07-30T07:03:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一字节对齐的概念">一.字节对齐的概念</h2>
<p>计算机系统对基本数据类型的合法地址做了一些限制，这种限制称为对齐。</p>
<p>如：要求某些数据的地址只能以1或2或8或16的倍数。</p>
<h2 id="二字节对齐的原因">二.字节对齐的原因</h2>
<h3 id="1性能">1.性能</h3>
<p>字节对齐的根本原因在于提高数据的访问的效率。主要在于减少数据访问的次数，因为不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。如x86的一个总线周期只能访问偶地址的数据，所以若不进行对齐，一个原本可以一次访存获得的数据则需要2次甚至更多次才能得到。</p>
<h3 id="2平台原因">2.平台原因</h3>
<p>不是所有的硬件平台都能访问到任意地址上的任意数据</p>
<h2 id="三几种对齐的方式">三.几种对齐的方式</h2>
<h3 id="1数据类型自身的对齐自然对齐">1.数据类型自身的对齐(自然对齐)</h3>
<p>存放变量的地址为该变量在改平台上对应的数据类型大小的整数倍。</p>
<h3 id="2结构体或类的自身对齐">2.结构体或类的自身对齐</h3>
<p>结构体或类的首地址是其成员中自身对齐值最大的那个值的整数倍。</p>
<h3 id="3指定对齐值">3.指定对齐值</h3>
<p>#pragma pack (value)时的指定对齐值value。</p>
<p>例：#pragma pack (5)</p>
<p>int a = 4;</p>
<p>int b = 9;</p>
<p>即：按照5字节进行对齐</p>
<h3 id="4数据成员结构体和类的有效对齐值">4.数据成员，结构体和类的有效对齐值</h3>
<p>有效对齐值 = min{自身对齐值，当前指定对齐值}</p>
<h2 id="四结构体数据的对齐问题">四.结构体数据的对齐问题</h2>
<p>数据结构中的数据变量都是按照定义的先后顺寻进行存放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整 (即结构体成员变量占用总长度为结构体有效对齐值的整数倍) 。</p>
<ol>
<li>结构体字节对齐的细节和具体编译器实现相关，但一般而言满足三个准则： 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；</li>
<li>结构体每个成员相对结构体首地址的偏移量(offset注意偏移量是从0开始的)都是min{本成员大小,当前有效对齐值}的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)；</li>
<li>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。</li>
</ol>
<p>第一条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。</p>
<p>第二条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是min{本成员大小,当前有效对齐值}的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。</p>
<p>第三条：结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第三条，否则就必须在最后填充几个字节以达到本条要求。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ucosii运行流程]]></title>
        <id>https://yvainefire.github.io/post/ucosii-yun-xing-liu-cheng/</id>
        <link href="https://yvainefire.github.io/post/ucosii-yun-xing-liu-cheng/">
        </link>
        <updated>2020-07-28T13:04:04.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="ucosii运行流程">ucosii运行流程</h1>
<h2 id="一系统时钟中断额初始化">一.系统时钟中断额初始化</h2>
<p>SysTick中断初始化，在轮转调度过程中，需要一个时钟中断来进行任务的切换。时钟中断的频率就是系统的心跳，也被称为时基，它决定了操作系统进行任务切换的频率。</p>
<h2 id="二操作系统初始化">二.操作系统初始化</h2>
<h3 id="1osinithookbegin">1.OSInitHookBegin()</h3>
<p>主要进行一些扩展功能的初始化</p>
<h3 id="2os_initmisc">2.OS_InitMisc()</h3>
<p>主要作用：进行杂项变量的初始化，主要有以下内容需要被初始化</p>
<pre><code class="language-c">OSIntNesting    		中断嵌套层数清零
OSLockNesting			
OSTaskCtr				任务计数清零
OSRunning				操作系统运行标志位清零
OSCtxSwCtr				任务切换计数清零
OSIdleCtr				
</code></pre>
<h3 id="3os_initrdylist">3.OS_InitRdyList()</h3>
<p>就绪队列的初始化，所谓就绪队列指由就绪任务构成的队列，但是这里实际上初始化的并不是队列，就绪队列里面保存的也不是就绪任务的TCB。</p>
<pre><code class="language-c">//以下是就绪队列实现的定义和初始化的代码
typedef unsigned char INT8U;

typedef  INT8U    OS_PRIO;

OS_EXT  OS_PRIO           OSRdyTbl[OS_RDY_TBL_SIZE];

for (i = 0u; i &lt; OS_RDY_TBL_SIZE; i++) {
        OSRdyTbl[i] = 0u;
    }

</code></pre>
<p>从这里可以看出，就绪队列的本质是一个8位无符号整型数组，仅仅保存的是一个整型，而不是TCB或者TCB指针。</p>
<p>为什么仅仅保存整型就可以表示就绪队列呢？这个以后再说。</p>
<p>除了初始化就绪队列，还初始化了两个与优先级相关的变量以及两个和任务TCB相关的量。<br>
OSPrioCur	   		保存当前任务的优先级<br>
OSPrioHighRdy      保存当前就绪队列优先级最高的任务的优先级<br>
OSTCBCur 	          保存当前任务的TCB指针<br>
OSTCBHighRdy      保存当前就绪队列中最高优先级任务的TCB指针</p>
<h3 id="4os_inittcblist">4.OS_InitTCBList ()</h3>
<p>初始化TCB链表，这里主要强调的链表，主要是把在头文件里声明的</p>
<p>OS_TCB	OSTCBTbl[OS_MAX_TASKS + OS_N_SYS_TASKS];		这个TCB数组拆开然后用指针将其连接起来。</p>
<pre><code class="language-c">for (ix = 0u; ix &lt; (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
        ix_next =  ix + 1u;
        ptcb1   = &amp;OSTCBTbl[ix];
        ptcb2   = &amp;OSTCBTbl[ix_next];
        ptcb1-&gt;OSTCBNext = ptcb2;
}

ptcb1                   = &amp;OSTCBTbl[ix];
ptcb1-&gt;OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
OSTCBFreeList           = &amp;OSTCBTbl[0];
</code></pre>
<p>除了进行free TCBs的初始化，还会进行以下两个变量的初始化</p>
<pre><code>OS_MemClr((INT8U *)&amp;OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
/*这里采取的强制转换很有意思。
OSTCBList	= (OS_TCB *)0;
</code></pre>
<p>OSTCBPrioTbl[]是用来存放对应的下标为优先级的任务的TCB指针，若该对应下标的任务已经被创建才会有相应的TCB指针，否则保持初始化的空值。这个表的作用是为了快速找个某一优先级对应的任务的任务指针。</p>
<p>OSTCBList就是指向任务块链表的头指针，这里面的任务包括当前所有存在的任务，就绪的，未就绪的。</p>
<h3 id="5os_initeventlist">5.OS_InitEventList()</h3>
<p>事件控制块链表的初始化，这个属于扩展的功能，与任务之间的通信相关，所以就先不讨论了，等到任务通信这个模块再进行讨论。</p>
<h2 id="三任务的创建">三.任务的创建</h2>
<h3 id="1任务函数的格式">1.任务函数的格式</h3>
<p>在ucosii中任务的形式如下：</p>
<p>实际上任务就是一个不带返回值具有死循环的函数</p>
<pre><code class="language-c">void task(void *p_arg)
{		
		while(1)
		{

		}
		
}
</code></pre>
<h3 id="2ostaskcreate">2.OSTaskCreate(）</h3>
<p>任务的创建</p>
<pre><code class="language-c">INT8U  OSTaskCreate (void   (*task)(void *p_arg),
                     void    *p_arg,
                     OS_STK  *ptos,
                     INT8U    prio)
    //任务函数
    //任务所需的参数
    //堆栈
    //优先级
</code></pre>
<ul>
<li>
<p>确保未在ISR中进行任务的创建。利用中断的嵌套层数OSIntNesting进行判断</p>
</li>
<li>
<p>对相应优先级的任务对应的OSTCBPrioTbl[prio]进行占位。由于ucosii仅支持的同一优先级的任务仅有一个，所以需先判断正在创建的任务的优先级是否已经被占用了。</p>
</li>
<li>
<p>堆栈初始化</p>
<pre><code class="language-c"> OS_STK *OSTaskStkInit (void (*task)(void *p_arg), 
 void *p_arg, OS_STK *ptos, INT16U opt)
</code></pre>
<p>所谓堆栈的初始化实际上就是对相关的寄存器进行模拟压栈的操作，并返回压栈后的栈顶指针。模拟压栈就是模仿任务切换时对相应寄存器进行的压栈操作。在这里主要的功能是确定堆栈栈顶指针的位置，同时把设置LR寄存器的值，并保存任务函数的地址，以及任务函数的参数指针。而其余的几个寄存器的值在这时是无意义的，不必关心其模拟压栈的内容。</p>
</li>
<li>
<p>TCB初始化</p>
<p>OS_TCBInit()</p>
<ul>
<li>从OSTCBFreeList获得一个空的tcb</li>
<li>把任务的相关信息放到这个空的tcb的相应位置</li>
<li>把被占位的OSTCBPrioTbl[]进行赋值，ptcb</li>
<li>把该tcb链入TCB链表</li>
<li>把该任务放进就绪队列</li>
</ul>
</li>
<li>
<p>是否开始调度</p>
<p>在这里还不会进行调度，因为调度的条件是OSRunning == OS_TRUE，而现在OSRunning == OS_FALSE。</p>
<p>OS_Sched()     //Schedule only if all ISRs done</p>
<ul>
<li>OS_SchedNew()  获得当前就绪队列中的最高的优先级，采用优先级位图的方式直接获得</li>
<li>判断当前执行的任务是否为最高优先级的任务，若不是则调用OS_TASK_SW()则进行任务切换。</li>
</ul>
</li>
</ul>
<h2 id="四操作系统的启动">四.操作系统的启动</h2>
<p>OSStart()</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="ucosii运行流程">ucosii运行流程</h1>
<h2 id="一系统时钟中断额初始化">一.系统时钟中断额初始化</h2>
<p>SysTick中断初始化，在轮转调度过程中，需要一个时钟中断来进行任务的切换。时钟中断的频率就是系统的心跳，也被称为时基，它决定了操作系统进行任务切换的频率。</p>
<h2 id="二操作系统初始化">二.操作系统初始化</h2>
<h3 id="1osinithookbegin">1.OSInitHookBegin()</h3>
<p>主要进行一些扩展功能的初始化</p>
<h3 id="2os_initmisc">2.OS_InitMisc()</h3>
<p>主要作用：进行杂项变量的初始化，主要有以下内容需要被初始化</p>
<pre><code class="language-c">OSIntNesting    		中断嵌套层数清零
OSLockNesting			
OSTaskCtr				任务计数清零
OSRunning				操作系统运行标志位清零
OSCtxSwCtr				任务切换计数清零
OSIdleCtr				
</code></pre>
<h3 id="3os_initrdylist">3.OS_InitRdyList()</h3>
<p>就绪队列的初始化，所谓就绪队列指由就绪任务构成的队列，但是这里实际上初始化的并不是队列，就绪队列里面保存的也不是就绪任务的TCB。</p>
<pre><code class="language-c">//以下是就绪队列实现的定义和初始化的代码
typedef unsigned char INT8U;

typedef  INT8U    OS_PRIO;

OS_EXT  OS_PRIO           OSRdyTbl[OS_RDY_TBL_SIZE];

for (i = 0u; i &lt; OS_RDY_TBL_SIZE; i++) {
        OSRdyTbl[i] = 0u;
    }

</code></pre>
<p>从这里可以看出，就绪队列的本质是一个8位无符号整型数组，仅仅保存的是一个整型，而不是TCB或者TCB指针。</p>
<p>为什么仅仅保存整型就可以表示就绪队列呢？这个以后再说。</p>
<p>除了初始化就绪队列，还初始化了两个与优先级相关的变量以及两个和任务TCB相关的量。<br>
OSPrioCur	   		保存当前任务的优先级<br>
OSPrioHighRdy      保存当前就绪队列优先级最高的任务的优先级<br>
OSTCBCur 	          保存当前任务的TCB指针<br>
OSTCBHighRdy      保存当前就绪队列中最高优先级任务的TCB指针</p>
<h3 id="4os_inittcblist">4.OS_InitTCBList ()</h3>
<p>初始化TCB链表，这里主要强调的链表，主要是把在头文件里声明的</p>
<p>OS_TCB	OSTCBTbl[OS_MAX_TASKS + OS_N_SYS_TASKS];		这个TCB数组拆开然后用指针将其连接起来。</p>
<pre><code class="language-c">for (ix = 0u; ix &lt; (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
        ix_next =  ix + 1u;
        ptcb1   = &amp;OSTCBTbl[ix];
        ptcb2   = &amp;OSTCBTbl[ix_next];
        ptcb1-&gt;OSTCBNext = ptcb2;
}

ptcb1                   = &amp;OSTCBTbl[ix];
ptcb1-&gt;OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
OSTCBFreeList           = &amp;OSTCBTbl[0];
</code></pre>
<p>除了进行free TCBs的初始化，还会进行以下两个变量的初始化</p>
<pre><code>OS_MemClr((INT8U *)&amp;OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
/*这里采取的强制转换很有意思。
OSTCBList	= (OS_TCB *)0;
</code></pre>
<p>OSTCBPrioTbl[]是用来存放对应的下标为优先级的任务的TCB指针，若该对应下标的任务已经被创建才会有相应的TCB指针，否则保持初始化的空值。这个表的作用是为了快速找个某一优先级对应的任务的任务指针。</p>
<p>OSTCBList就是指向任务块链表的头指针，这里面的任务包括当前所有存在的任务，就绪的，未就绪的。</p>
<h3 id="5os_initeventlist">5.OS_InitEventList()</h3>
<p>事件控制块链表的初始化，这个属于扩展的功能，与任务之间的通信相关，所以就先不讨论了，等到任务通信这个模块再进行讨论。</p>
<h2 id="三任务的创建">三.任务的创建</h2>
<h3 id="1任务函数的格式">1.任务函数的格式</h3>
<p>在ucosii中任务的形式如下：</p>
<p>实际上任务就是一个不带返回值具有死循环的函数</p>
<pre><code class="language-c">void task(void *p_arg)
{		
		while(1)
		{

		}
		
}
</code></pre>
<h3 id="2ostaskcreate">2.OSTaskCreate(）</h3>
<p>任务的创建</p>
<pre><code class="language-c">INT8U  OSTaskCreate (void   (*task)(void *p_arg),
                     void    *p_arg,
                     OS_STK  *ptos,
                     INT8U    prio)
    //任务函数
    //任务所需的参数
    //堆栈
    //优先级
</code></pre>
<ul>
<li>
<p>确保未在ISR中进行任务的创建。利用中断的嵌套层数OSIntNesting进行判断</p>
</li>
<li>
<p>对相应优先级的任务对应的OSTCBPrioTbl[prio]进行占位。由于ucosii仅支持的同一优先级的任务仅有一个，所以需先判断正在创建的任务的优先级是否已经被占用了。</p>
</li>
<li>
<p>堆栈初始化</p>
<pre><code class="language-c"> OS_STK *OSTaskStkInit (void (*task)(void *p_arg), 
 void *p_arg, OS_STK *ptos, INT16U opt)
</code></pre>
<p>所谓堆栈的初始化实际上就是对相关的寄存器进行模拟压栈的操作，并返回压栈后的栈顶指针。模拟压栈就是模仿任务切换时对相应寄存器进行的压栈操作。在这里主要的功能是确定堆栈栈顶指针的位置，同时把设置LR寄存器的值，并保存任务函数的地址，以及任务函数的参数指针。而其余的几个寄存器的值在这时是无意义的，不必关心其模拟压栈的内容。</p>
</li>
<li>
<p>TCB初始化</p>
<p>OS_TCBInit()</p>
<ul>
<li>从OSTCBFreeList获得一个空的tcb</li>
<li>把任务的相关信息放到这个空的tcb的相应位置</li>
<li>把被占位的OSTCBPrioTbl[]进行赋值，ptcb</li>
<li>把该tcb链入TCB链表</li>
<li>把该任务放进就绪队列</li>
</ul>
</li>
<li>
<p>是否开始调度</p>
<p>在这里还不会进行调度，因为调度的条件是OSRunning == OS_TRUE，而现在OSRunning == OS_FALSE。</p>
<p>OS_Sched()     //Schedule only if all ISRs done</p>
<ul>
<li>OS_SchedNew()  获得当前就绪队列中的最高的优先级，采用优先级位图的方式直接获得</li>
<li>判断当前执行的任务是否为最高优先级的任务，若不是则调用OS_TASK_SW()则进行任务切换。</li>
</ul>
</li>
</ul>
<h2 id="四操作系统的启动">四.操作系统的启动</h2>
<p>OSStart()</p>
<!-- more -->
<h3 id="1判断osrunning-os_false">1.判断OSRunning == OS_FALSE</h3>
<h3 id="2os_schednew">2.OS_SchedNew()</h3>
<p>获得当前就绪队列中的最高的优先级，采用优先级位图的方式直接获得</p>
<h3 id="3设置ospriocurostcbhighrdyostcbcur">3.设置OSPrioCur，OSTCBHighRdy，OSTCBCur</h3>
<h3 id="4osstarthighrdy">4.OSStartHighRdy()</h3>
<p>设置PendSV的中断优先级</p>
<p>初始化PSP</p>
<p>设置OSRunning标志为1</p>
<p>开启PendSV中断。</p>
]]></content>
    </entry>
</feed>