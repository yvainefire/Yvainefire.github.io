<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yvainefire.github.io</id>
    <title>YvaineFire_block</title>
    <updated>2021-05-06T10:49:07.296Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yvainefire.github.io"/>
    <link rel="self" href="https://yvainefire.github.io/atom.xml"/>
    <subtitle>Rush Rush B</subtitle>
    <logo>https://yvainefire.github.io/images/avatar.png</logo>
    <icon>https://yvainefire.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, YvaineFire_block</rights>
    <entry>
        <title type="html"><![CDATA[SVC 和 PendSV]]></title>
        <id>https://yvainefire.github.io/post/svc-he-pendsv/</id>
        <link href="https://yvainefire.github.io/post/svc-he-pendsv/">
        </link>
        <updated>2021-05-06T10:21:43.000Z</updated>
        <content type="html"><![CDATA[<p>SVC和PendSV多用于操作系统的开发之上，用于将硬件层和应用层分开。</p>
<h2 id="svc系统调用服务">SVC系统调用服务</h2>
<p>SVC是一种异常，对应一个特定的SVC异常服务程序。同时使用SVC系统调用服务的时候还需要一个对应的立即数充当系统调用号。根据这个立即数，去调用相应的系统服务函数以实现应用程序对底层硬件的间接调用。</p>
<p>特点：不能嵌套SVC调用，该异常必须被立即响应，若由于当前正在处理更高优先级的异常或其它的原因，则会产生一个硬件fault。</p>
<h2 id="pendsv可悬起的系统调用">PendSV可悬起的系统调用</h2>
<p>PendSV和SVC执行一样的功能，但是PendSV可以向普通的中断被悬起，缓期再进行执行。若触发PendSV异常后，其优先级不够，则将被悬起，缓期执行。</p>
<p>将PendSV的优先级的设置为最低，可以使得在进行中断处理的时候不进行上下文的切换，从而防止出现systick异常抢占IRQ，并执行上下文切换，导致IRQ被延迟执行，从而影响系统对中断响应的实时性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[裸机系统和多任务系统]]></title>
        <id>https://yvainefire.github.io/post/luo-ji-xi-tong-he-duo-ren-wu-xi-tong/</id>
        <link href="https://yvainefire.github.io/post/luo-ji-xi-tong-he-duo-ren-wu-xi-tong/">
        </link>
        <updated>2021-05-06T10:20:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="裸机系统">裸机系统</h2>
<p>裸机系统包括轮询系统和前后台系统</p>
<h3 id="轮询系统">轮询系统</h3>
<ul>
<li>结构：主程序是一个死循环，程序顺序执行。</li>
<li>响应和处理：外部事件由主程序进行响应，由主程序进行执行。</li>
<li>实时性：实时性较差。可能会导致事件的未被响应。轮询相应，轮询处理。</li>
</ul>
<h3 id="前后台系统">前后台系统</h3>
<ul>
<li>结构：在轮询系统的基础上加上了中断响应。前台响应中断并标记事件，如果处理的事件较简单则可以直接在中断中处理否则在后台中执行，后台为main函数里的无限循环，判断是否有事件被标记了并进行处理。</li>
<li>响应和处理：外部事件由中断响应，由中断或主程序处理</li>
<li>实时性：相比轮询系统，前后台系统确保了事件不会丢失。实时响应事件，但是只能轮询处理。</li>
</ul>
<h2 id="多任务系统">多任务系统</h2>
<ul>
<li>结构：在前后台系统的基础上，加入了任务的概念。任务是一个无限循环且不返回会的函数，各个任务之间相互独立，同时具备和中断一样的优先级，并由操作系统进行调度和管理。</li>
<li>响应和处理：外部事件由中断响应，由中断或任务处理</li>
<li>实时性：实时性可以很强。实时响应事件，并且实时处理事件。</li>
</ul>
<p><code>当一个紧急的事件在中断被标记之后，如果事件对应的任务的优先级足够高， 就会立马得到响应。</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FreeRTOS 任务切换]]></title>
        <id>https://yvainefire.github.io/post/freertos-ren-wu-qie-huan/</id>
        <link href="https://yvainefire.github.io/post/freertos-ren-wu-qie-huan/">
        </link>
        <updated>2021-05-06T10:18:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="调用的第一个任务的汇编函数">调用的第一个任务的汇编函数</h2>
<p>使用SVC中断，从当前任务的TCB中找到其栈顶，然后将栈里面的数据恢复到CPU的寄存器中，最后返回。</p>
<p>调用SVC中断时，如果当响应异常时，当前的代码正在使用PSP，则压入 PSP，即使用线程堆栈；否则压入MSP，使用主堆栈。一旦进入了服务例程，就将一直使用 主堆栈。所以之前的那一状态的寄存器的值会被保存到MSP中，依次自动保存xPSR, PC, LR, R12以及 R3‐R0由硬件自动压入MSP的堆栈中。</p>
<p>进入异常服务程序后，LR的值会被自动赋予为新的特殊的EXC_RETURN，只有[3:0]的值有特殊含义，以决定异常返回时进入是线程模式还是handler模式，使用MSP还是PSP，使用ARM指令还是Thumb指令。</p>
<p>退出异常时，需要手动把这个EXC_RETURN值送往PC时（使用跳转指令），就会启动处理器的异常中断返回序列，进行寄存器值得自动恢复及NVIC的清楚等等。进而更改PC的值，从而改变取指令的地址从而，跳转到指定位置，继续执行。</p>
<h2 id="使用pendsv进行上下文切换">使用PendSV进行上下文切换</h2>
<h3 id="流程">流程</h3>
<ol>
<li>在线程模式下触发PendSV异常，当该异常被响应并执行中断服务程序之前，硬件自动将xPSR, PC, LR, R12以及 R3‐R0这几个寄存器的值保存到PSP指向的任务堆栈中，再更新PSP指针到相应的位置。</li>
<li>进入PendSV的中断服务程序后，将自动更改堆栈为MSP，R14的值也会被自动更改为一个EXC_RETURN的值。</li>
<li>手动进行要被替换的任务的r4-r11寄存器值的保存，如果具有浮点运算单元，还需要保存浮点运算单元对应的寄存器，这里需要手动指定为PSP堆栈指针，最后需要使用PSP来更新该任务TCB中的堆栈指针。</li>
<li>将R14暂存到SP堆栈中，即MSP堆栈中，避免接下来调用子函数进行确定新的任务时被覆盖掉，从而在最后退出异常时手动把这个EXC_RETURN值送往PC时出错。</li>
<li>调用子函数确定接下来的currentTCB，即找到即将要执行的新任务的TCB，并用其更新currentTCB。</li>
<li>从MSP堆栈中，恢复R14</li>
<li>利用currentTCB，找到新任务的堆栈指针的header，并使用header将堆栈中对应的值赋给r4-r11寄存器。最后更新psp为当新任务的堆栈指针。</li>
<li>使用bx r14，进行返回，触发异常返回序列。</li>
</ol>
<p>问题：在新任务的TCB中，并没有响应的更改其header for the stack，因为在任务执行的时，是不会使用这个stack的，在下次任务切换的时候，这个新任务做为被保存上下文的任务，再更新这个header for the stack。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FreeRTOS	任务]]></title>
        <id>https://yvainefire.github.io/post/freertos-ren-wu/</id>
        <link href="https://yvainefire.github.io/post/freertos-ren-wu/">
        </link>
        <updated>2021-05-06T10:17:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="任务控制块">任务控制块</h2>
<p>任务控制块TCB的结构</p>
<pre><code class="language-c">typedef struct tskTaskControlBlock
{
	volatile StackType_t *pxTopOfStack; /* define the pointer for the head of the stack*/
	
	ListItem_t xStateListItem; /* define the node for the task*/
	
	StackType_t *pxStack;	/* define the start address for the task*/
	
	char pcTaskName[configUSE_16_BIT_TICKS]; /* define the name string for a task*/
	
}tskTCB;
</code></pre>
<h2 id="任务的创建">任务的创建</h2>
<h3 id="任务创建的两种方式">任务创建的两种方式</h3>
<p>在FreeRTOS中任务的创建分为静态创建和动态创建。</p>
<ul>
<li>动态创建时，任务控制块和栈的内存是创建任务时动态分配的，任务删除时，内存可以删除。</li>
<li>静态创建时，任务控制块和栈的内存时事先定义好的，在任务删除后，该内存是不能被删除的。</li>
</ul>
<h3 id="创建过程">创建过程</h3>
<ul>
<li>xTaskCreate创建了一个新的TCB指针初始化部分的成员，并调用prvInitialiseNewTask进一步初始化这个TCB指针</li>
<li>prvInitialiseNewTask计算栈顶的位置，初始化TCB里面的LlistItem节点，并调用堆栈的初始化函数pxPortInitializeStack</li>
</ul>
<p><strong>关于堆栈过程中将任务的入口函数地址进行8bytes对齐的原因？</strong></p>
<h2 id="就绪队列">就绪队列</h2>
<p>就绪列表本质上是一个List_t类型（ListNode 的 Root节点）的数组。数组的下标对应了任务的优先级，同一优先级的任务统一插入到就绪列表的同一条链表中。</p>
<p>在使用就绪队列前，需要先对就绪队列里面的元素进行初始化，相当于初始化一些链表的Root节点(ListItem)。</p>
<p>每个任务创建之后需要将其插入其优先级对应的就绪队列中，等待被调度。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言 常量指针和指针常量]]></title>
        <id>https://yvainefire.github.io/post/c-yu-yan-chang-liang-zhi-zhen-he-zhi-zhen-chang-liang/</id>
        <link href="https://yvainefire.github.io/post/c-yu-yan-chang-liang-zhi-zhen-he-zhi-zhen-chang-liang/">
        </link>
        <updated>2021-04-27T10:52:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常量指针">常量指针</h2>
<p>指针指向的内容是常量，用这个常量指针无法改变指针指向的内容，但是可以用另一个指向相同地址的非常量指针去改变他们共同指向的内容。</p>
<pre><code class="language-c">int A = 1;
int B = 2;
const int * C = &amp;A; //定义一个常量指针
int const * B = &amp;A; //定义一个常量指针
</code></pre>
<h2 id="指针常量">指针常量</h2>
<p>指针常量是指这个指针是一个常量，即不能将这个指针指向其它的地址，即不能改变这个指针本身。</p>
<pre><code class="language-c">int A = 1;
int B = 2;
int * const n =&amp;A; //定义一个指针常量
</code></pre>
<p><strong>注：区分常量指针和指针常量，可以通过const在 * 的左边还是右边。</strong></p>
<h2 id="常量指针常量">常量指针常量</h2>
<p>同时具有常量指针和指针常量的特点，既无法修改指针指向的内容也无法修改指针本身。</p>
<pre><code class="language-c">int A = 1;
const int * const C = &amp;A;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++面向对象 data member初始化]]></title>
        <id>https://yvainefire.github.io/post/cmian-xiang-dui-xiang-cheng-yuan-chu-shi-hua/</id>
        <link href="https://yvainefire.github.io/post/cmian-xiang-dui-xiang-cheng-yuan-chu-shi-hua/">
        </link>
        <updated>2021-04-08T12:33:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="constructor">constructor</h2>
<p>C++的所有成员未初始化的成员通过构造函数进行操作，构造函数（constructor）</p>
<p>构造函数的特点：</p>
<ul>
<li>名称和class的名称一样</li>
<li>构造函数的不应该指定返回类型</li>
<li>构造函数允许被重载</li>
<li>构造函数在类被定义后根据传入参数的类型进行选择并调用</li>
</ul>
<h2 id="destructor">destructor</h2>
<p>与构造函数对应的就是析构函数（destructor），对构造函数中分配的资源进行释放回收，完成heap内存的管理。</p>
<p>析构函数的特点：</p>
<ul>
<li>析构函数的名称是class名前加个~</li>
<li>析构函数没有返回值</li>
<li>析构函数不带任何参数</li>
<li>析构函数不能被重载</li>
</ul>
<h2 id="default-constructor">default constructor</h2>
<p>不需要任何参数，不接受参数或者是提供默认参数</p>
<pre><code class="language-c++">class_name(int a=1, int b=2){
	data_member_1 = a;
	data_member_2 = b;
}
</code></pre>
<h2 id="member-initialization-list">Member Initialization List</h2>
<p>C++的的构造函数除了具有一般函数的特征外。还可以具有初始化列表。初始化列表更在函数参数的括号后面，以 : 开头</p>
<pre><code class="language-c++">class_name(int a, int b):data_member_1(a),data_member_2(b)
{

}
</code></pre>
<h2 id="memberwise-initialzation">Memberwise Initialzation</h2>
<p>用一个class object 来初始化另一个object</p>
<p>eg:</p>
<pre><code class="language-c++">class_name obj_1(paraments);
class_name obj_2 = obj_1;
</code></pre>
<p>把obj_1这个类里面的成员变量的值直接通过operator=赋给obj_2。</p>
<p>这里可能会出现一个问题如果成员变量里面有的值是指针形式的，那么这样的操作会使指针指向同一个地址。如果每个class object的destructor都对之指针指向的内容进行回收那么就可能会导致一些错误。为了解决这个问题可以采用重载一个const class_name &amp;object_name的构造函数，进行手动的赋值操作，申请一个新的内存空间用于指针指向。</p>
<h2 id="c构造函数的两个阶段">C++构造函数的两个阶段</h2>
<h3 id="初始化阶段">初始化阶段</h3>
<ul>
<li>调用初始化列表</li>
<li>未初始化的类成员（不在初始化列表）调用默认构造函数</li>
</ul>
<h3 id="计算阶段">计算阶段</h3>
<p>在执行完初始化阶段后，执行构造体函体内的赋值操作，进行初始化。</p>
<p><strong>具体顺序</strong>：成员变量被初始化的顺序是由成员变量在class里面声明的顺序决定的，先声明的先初始化。初始化的顺序是先利用初始化参数表进行初始化，根据初始化参数表提供的参数类型，选择相应的构造函数进行初始化，可以把初始化参数表种没有提到的参数，默认是其调用了不含参数的构造函数，也就是说所有的未初始化的成员变量如果有不含参数的构造方法都会在调用初始化参数列表时调用一种构造方法进行构造。然后再根据构造函数里面的计算赋值阶段。</p>
<p>eg:</p>
<pre><code class="language-c++">class BaseTest1{
public:
    BaseTest1();
    BaseTest1(const BaseTest1&amp; t1);
    BaseTest1&amp; operator=(const BaseTest1&amp; t1);
private:
    int a;
};

BaseTest1::BaseTest1()
{
    cout &lt;&lt; &quot;BaseTest1 Constructor&quot; &lt;&lt; endl;
    this-&gt;a = 0;
}

BaseTest1::BaseTest1(const BaseTest1 &amp;t1)
{
    cout &lt;&lt; &quot;BaseTest1 Copy Constructor&quot; &lt;&lt; endl;
    this-&gt;a = t1.a;
}

BaseTest1&amp; BaseTest1::operator=(const BaseTest1 &amp;t1)
{
    cout &lt;&lt; &quot;BaseTest1 assignment&quot; &lt;&lt; endl;
    this-&gt;a = t1.a;
    return *this;
}

class BaseTest2
{
public:
    BaseTest2()
    {
        cout &lt;&lt; &quot;BaseTest2 Constructor&quot; &lt;&lt; endl;
        this-&gt;a = 0;
    }
    BaseTest2(const BaseTest2&amp; t)
    {
        cout &lt;&lt; &quot;BaseTest2 Copy Constructor&quot; &lt;&lt; endl;
        this-&gt;a = t.a;
    }
    BaseTest2&amp; operator=(const BaseTest2&amp; t)
    {
        cout &lt;&lt; &quot;BaseTest2 assignment&quot; &lt;&lt; endl;
        this-&gt;a = t.a;
        return *this;
    }
private:
    int a;
};


class Test{
public:
    Test(BaseTest1&amp; t1, BaseTest2&amp; t2):test1(t1)
    {
        this-&gt;test2 = t2;
    }

public:
    BaseTest2 test2;
    BaseTest1 test1;
};


int main(int argc, char* args[])
{
    BaseTest1 test1;
    BaseTest2 test2;
    Test test(test1, test2);
}
————————————————
版权声明：代码为CSDN博主「惜暮」的原创
代码链接：https://blog.csdn.net/u010853261/article/details/85036025
</code></pre>
<p>执行结果：</p>
<pre><code>BaseTest1 Constructor
BaseTest2 Constructor
BaseTest2 Constructor
BaseTest1 Copy Constructor
BaseTest2 assignment
</code></pre>
<p>使用初始化列表可以减少计算阶段的赋值操作，毕竟大多数时候成员变量在调用初始化列表的时候都会采用一种构造方法进行初始化。</p>
<p>注意：在列表调用初始化阶段时如果涉及到成员变量的作为参数，则一定要注意成员变量在class中定义的顺序，防止未定义的情况出现。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STL标准库]]></title>
        <id>https://yvainefire.github.io/post/stl-biao-zhun-ku/</id>
        <link href="https://yvainefire.github.io/post/stl-biao-zhun-ku/">
        </link>
        <updated>2021-04-08T08:21:48.000Z</updated>
        <content type="html"><![CDATA[<p>C++标准库 能看见source code</p>
<p>STL是C++标准库中的部分</p>
<p>header files:不带.h</p>
<p>name space:命名空间，避免命名冲突</p>
<p>常用网站：</p>
<ul>
<li>CPlusPlus.com</li>
<li>CppReference.com</li>
<li>gcc.gnu.org</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 面向对象 类的声明和定义]]></title>
        <id>https://yvainefire.github.io/post/c-mian-xiang-dui-xiang-lei-de-sheng-ming-he-ding-yi/</id>
        <link href="https://yvainefire.github.io/post/c-mian-xiang-dui-xiang-lei-de-sheng-ming-he-ding-yi/">
        </link>
        <updated>2021-04-08T08:20:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="类的声明">类的声明</h2>
<p>类的声明以关键是 class开始，</p>
<pre><code class="language-c++">class class_name;
</code></pre>
<p>类的前置声明只是告诉编译器有这个类的存在，同时可以定义类指针</p>
<h2 id="类的定义">类的定义</h2>
<p>class 声明  +  声明后的主体</p>
<pre><code class="language-c++">class class_template{
pubilic:

private:

}
</code></pre>
<p>主体内包括data member和member function，同时这两种都具有public或者private属性，public属性的可以被类外访问，private属性的只能被类里面的东西访问。</p>
<p>member function 必须在类里面声明，但不一定在类里面定义。在类里面定义的时候会被默认定义为inline函数。在类外定义是需要特殊指定是哪个类的函数。</p>
<pre><code class="language-c++">class class_template{
pubilic:
	void function_1(int a);
	void function_2(int b);

	void funciton_2(int b)
	{
		.......
	}
private:
	int c;
}

void class_template::function_2(int a)
{
	.......
}
</code></pre>
<p>data member必须通过特殊的方式进行初始化即构造函数（constructor）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 泛型指针]]></title>
        <id>https://yvainefire.github.io/post/c-fan-xing-zhi-zhen/</id>
        <link href="https://yvainefire.github.io/post/c-fan-xing-zhi-zhen/">
        </link>
        <updated>2021-04-08T08:20:29.000Z</updated>
        <content type="html"><![CDATA[<p>C++的泛型指针是针对容器元素而言的，相当于是容器的指针</p>
<h2 id="泛型指针的定义">泛型指针的定义</h2>
<pre><code class="language-c++">vector&lt;class&gt;::iterator iter = vertor_template.begin();
//class 是vector的类型，vec_template是一个已经定义的容器。begin()是这个容器的第一个元素的指针
vector&lt;class&gt;::iterator iter = vertor_template.end();
//end 是这个容器的最后一个元素的指针
</code></pre>
<h2 id="泛型指针的操作">泛型指针的操作</h2>
<p>具有和一般指针一样的dereference（提领 *），inequality(不等 ！=)，increment（递增， ++）等操作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 函数编写]]></title>
        <id>https://yvainefire.github.io/post/c-han-shu-bian-xie/</id>
        <link href="https://yvainefire.github.io/post/c-han-shu-bian-xie/">
        </link>
        <updated>2021-04-03T07:23:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="使用带默认参数的函数">使用带默认参数的函数</h2>
<p>C++提供了带默认参数的函数。</p>
<p>eg:</p>
<pre><code class="language-c++">void function_paramt(int a, int b, int c = 1)
{
	....
	....
}
</code></pre>
<p>在函数的定义或声明中可以为其添加默认的参数，当调用这个函数的时候，如果没有第三个参数的形参，则默认等于1。否则以形参的值为准。</p>
<p>注意在使用带默认参数的函数时有两条规则：</p>
<ul>
<li>对默认参数的解析是从右往左开开始，所以从左往右第一个使用默认参数的参数其右边的所以参数都必须使用默认参数。</li>
<li>在函数的声明和定义中只能够有一个地方使用了默认参数，建议在函数声明的位置使用默认参数。</li>
</ul>
<h2 id="使用inline声明函数">使用inline声明函数</h2>
<p>为了提高函数的效率减少函数之间调用所产生的开销，可以使用inline来声明一个函数，从而使该函数内部调用的函数，在编译的时候能展开，从而减少了一个函数对另一个函数的调用。</p>
<p>inline的作用简单来说就是对函数进行展开。</p>
<p>eg:</p>
<pre><code class="language-c++">inline void il_templet(int a, int b)
{
	fun1();
	fun2();
	.......
}
</code></pre>
<p>注意：inline只是对编译器提出的一种请求，并不是强制性的。所以编译是否会执行，还需要根据编译器而定。</p>
<h2 id="函数的重载">函数的重载</h2>
<p>不同于C语言，C++可以对函数进行重载，所谓重载也就是指对一个同名的函数可以根据其参数的不同而进行区别。这里参数不同可以指参数的类型不同，参数的数量不同。</p>
<p>在调用函数的时候，根据调用时所给定的形参来选择相应的函数进行调用。</p>
<p>eg:</p>
<pre><code class="language-c++">void func_overlaoding_1();
void func_overlaoding_1(int a);
void func_overlaoding_1(string a);
void func_overlaoding_1(int a, int b);
......
</code></pre>
<p>注意：返回类型并不作为区分函数重载的依据，因为调用函数的时候，用时候并不会使用到其返回类型，这就导致了编译器不能对齐进行解析。</p>
<h2 id="模板函数">模板函数</h2>
<p>当一个几个函数函数体相似，而仅仅是函数中某个变量的数据类型不一样的时，可以使用定义一个函数模板方式，来减少定义多个类似的函数。</p>
<p>定义一个函数模板，最开始以关键字template开头，然后用&lt; &gt;包含多个标识符。</p>
<p>eg:</p>
<pre><code class="language-c++">template &lt;typename elemType&gt;
void template_function(int a, vector&lt;elemType&gt; &amp;vec)
{
.......
}
</code></pre>
<p>使用一个函数模板，先定义模板中未定义的参数的类型</p>
<p>eg:</p>
<pre><code class="language-c++">vector&lt;int&gt; ivec;
template_function(a, ivec);
</code></pre>
]]></content>
    </entry>
</feed>