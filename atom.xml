<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yvainefire.github.io</id>
    <title>YvaineFire_block</title>
    <updated>2021-07-12T09:37:03.532Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yvainefire.github.io"/>
    <link rel="self" href="https://yvainefire.github.io/atom.xml"/>
    <subtitle>Rush Rush B</subtitle>
    <logo>https://yvainefire.github.io/images/avatar.png</logo>
    <icon>https://yvainefire.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, YvaineFire_block</rights>
    <entry>
        <title type="html"><![CDATA[STM32 启动文件]]></title>
        <id>https://yvainefire.github.io/post/stm32-qi-dong-wen-jian/</id>
        <link href="https://yvainefire.github.io/post/stm32-qi-dong-wen-jian/">
        </link>
        <updated>2021-05-13T08:56:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="上电复位后的工作">上电复位后的工作</h2>
<ul>
<li>初始化堆栈指针</li>
<li>初始化PC指针</li>
<li>初始化中断表</li>
<li>配置系统时钟</li>
<li>调用C库函数_main初始化用户堆栈，调用用户编写的main函数</li>
</ul>
<h2 id="分配栈空间并初始化栈指针">分配栈空间并初始化栈指针</h2>
<p>栈空间主要用于存储局部变量，函数调用时分配的栈，函数传参</p>
<pre><code class="language-assembly">Stack_Size      EQU     0x00000400

                AREA    STACK, NOINIT, READWRITE, ALIGN=3
Stack_Mem       SPACE   Stack_Size
__initial_sp
</code></pre>
<h2 id="分配堆空间并初始化堆指针">分配堆空间并初始化堆指针</h2>
<p>堆空间主要用于动态内存的分配，如malloc()函数</p>
<pre><code class="language-assembly">Heap_Size       EQU     0x00000C00

                AREA    HEAP, NOINIT, READWRITE, ALIGN=3
__heap_base
Heap_Mem        SPACE   Heap_Size
__heap_limit
</code></pre>
<h2 id="构造向量表">构造向量表</h2>
<p>构造一个只读的数据段，用于存放每一个中断对应的中断服务函数的地址。所以实际上相当于定义了一个数组。</p>
<pre><code class="language-assembly">; Vector Table Mapped to Address 0 at Reset

                AREA    RESET, DATA, READONLY
                EXPORT  __Vectors
                EXPORT  __Vectors_End
                EXPORT  __Vectors_Size

__Vectors       DCD     __initial_sp              ; Top of Stack
                DCD     Reset_Handler             ; Reset Handler
                DCD     NMI_Handler               ; NMI Handler
                DCD     HardFault_Handler         ; Hard Fault Handler
               ..........

__Vectors_End

__Vectors_Size  EQU     __Vectors_End - __Vectors
</code></pre>
<p>这些都是实现定义好的函数名，用户只需要在用户程序中填充需要使用的中断服务函数。</p>
<p>NVIC的重定位寄存器的是指向向量表的，复位为0，所以0地址必须要有一个向量表。</p>
<h2 id="复位程序">复位程序</h2>
<p>调用 SystemInit 函数初始化系统时钟，SystemInit 函数是一个标准的库函数用于配置时钟系统。</p>
<p>调用 C 库函数__mian，__mian函数是一个标准的C库函数，主要用于初始化用户堆栈，并最终调用 main 函数去到 C 的世界。</p>
<h2 id="初始化用户堆栈">初始化用户堆栈</h2>
<pre><code class="language-assembly">__user_initial_stackheap PROC
                LDR     R0, =  Heap_Mem
                LDR     R1, =(Stack_Mem + Stack_Size)
                LDR     R2, = (Heap_Mem +  Heap_Size)
                LDR     R3, = Stack_Mem
                BX      LR
</code></pre>
<p>在调试的时候可以看见</p>
<ul>
<li>堆的起始地址：R0 = 0x20000A00</li>
<li>栈顶：R1 = 0x20001A00</li>
<li>堆顶：R2 = 0x20001600</li>
<li>栈的起始地址：R3 = 0x20001600</li>
</ul>
<p>这些地址都是位于存储器映射中的Block1，SRAM 64KB 中（0x2000 0000 ~0x2000 FFFF）</p>
<p>进入main函数中SP指针马上就变成了堆栈初始化后R1的值 0x20001A00，即指向栈顶。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 线程]]></title>
        <id>https://yvainefire.github.io/post/linux-xian-cheng/</id>
        <link href="https://yvainefire.github.io/post/linux-xian-cheng/">
        </link>
        <updated>2021-05-13T08:22:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="并发切换">并发：切换</h2>
<p>每一个进程之间是相互独立的，但是他们都共享了操作系统的API，并发性的来源是进程会调用系统的API。<br>
即便是拥有root权限的进程也不能修改操作系统内核的内存<br>
并发性的来源：进程会调用操作系</p>
<h2 id="线程共享的内容">线程共享的内容？</h2>
<p>共享：<br>
1.代码<br>
2.全局变量，静态局部变量<br>
3.堆区<br>
不共享：<br>
1.寄存器<br>
2.局部变量<br>
局部变量位于栈里，栈的位置由sp寄存器的值决定</p>
<h2 id="多线程">多线程</h2>
<p>__thread</p>
<p>__thread变量每一个线程有一份独立实体，各个线程的值互不干扰。可以用来修饰那些带有全局性且值可能变，但是又不值得用全局变量保护的变量。</p>
<p>为线程分配堆栈的时候只是被标记了，并没有实际上分出去，所以创建很多的线程即使分配的内存大于了总内存。同时每个堆栈区域的上限和下限都会设置一小段的不可访问的区域，所以无论上原了性的表失，即使溢或者下溢都会导致段错误。</p>
<p>在多线程编码的时候，失去了原子性，一条c语言语句被编译后可能会是几条汇编指令，根据这些指令的不同的执行顺序，可能会得到不一样的结果。</p>
<p>##编译器的优化问题<br>
可能会导致程序顺序的丧失，并发的时候出现错误。<br>
为了使cpu执行的更快，现代cpu可以不按照顺序进行执行指令，可能会把某条影响执行时间的指令放进一个等待队列中。<br>
顺序性<br>
原子性<br>
可见性<br>
volatile：修饰可防止被编译器优化<br>
#define barrier() asm volatile(“”:::”memory “)<br>
barrier可以防止多个连续的++指令被合并</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux  内核的基本概念]]></title>
        <id>https://yvainefire.github.io/post/linux-nei-he-de-ji-ben-gai-nian/</id>
        <link href="https://yvainefire.github.io/post/linux-nei-he-de-ji-ben-gai-nian/">
        </link>
        <updated>2021-05-13T08:21:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="内核的组成">内核的组成</h2>
<ul>
<li>中断服务管理程序</li>
<li>处理器调度程序</li>
<li>内存管理程序</li>
<li>网络通信等系统服务程序</li>
</ul>
<h2 id="两种运行态">两种运行态</h2>
<p>内核运行的空间----内核态，独立于普通的程序，拥有受保护的内核空间和访问硬件的所有权。</p>
<p>应用程序运行的空间----用户态，只能使用部分的系统资源，不能访问内核给别人的内存空间，不能直接使用硬件资源。</p>
<p>操作系统中运行的应用程序通过系统调用来与内核进行通信。系统调用又往往被封装为函数库提供给用户。</p>
<p>许多操作系统的中断服务程序都不在进程的上下文中执行，而执行在一个与进行上下文无关的专门的中断上下文，从而保证了中断响应的速度。</p>
<p>两种运行态下的三种活动：</p>
<ul>
<li>运行于用户空间，执行用户上下文。</li>
<li>运行于内核空间，处于进程上下文，使用当前进程的内核栈，代表某个特定进程执行。是由系统调用陷入内核态的。</li>
<li>运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断。</li>
</ul>
<p>中断上下文指：硬件传递过来的一些参数和内核需要保存的一些环境。</p>
<h2 id="两种内核">两种内核</h2>
<p>单内核：整体上作为一个大的过程，运行在一个单独的地址空间，内核之间可以直接通过函数调用进行通信。结构简单，性能高，不安全。</p>
<p>微内核：划分为很多独立的过程（称为服务器），每个独立的过程单独执行在各自的地址空间，通过消息传递进行内核模块间的通信。结果复杂，性能较低，</p>
<p>实际应用的微内核系统会将大部分或全部的服务器都放在内核中，从而达到直接进行函数调用达到通信的目的。</p>
<p>Linux是一个单内核，但是又具有微内核的特点，所有的事情都运行在内核中，直接调用函数，无需消息传递。</p>
<h2 id="linux内核的一些特点">Linux内核的一些特点</h2>
<ul>
<li>支持动态加载内核模块</li>
<li>支持对称多处理机制</li>
<li>内核可抢占</li>
<li>内核并不区分线程和进程，对内核来说所有的进程都一样，只是线程可以共享资源而已。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言 关于字符常量的一些说明]]></title>
        <id>https://yvainefire.github.io/post/c-yu-yan-guan-yu-zi-fu-chang-liang-de-yi-xie-shuo-ming/</id>
        <link href="https://yvainefire.github.io/post/c-yu-yan-guan-yu-zi-fu-chang-liang-de-yi-xie-shuo-ming/">
        </link>
        <updated>2021-05-13T08:20:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1为什么字符串常量无法被修改">1为什么字符串常量无法被修改</h2>
<p>当程序在使用字符串常量的时候会生成一个指向字符的常量指针，当一个字符串常量出现在一个表达式的时候，表达式所使用的值就是这个字符串所指向的字符串常量。</p>
<h2 id="2为什么无法直接把字符串常量赋给一个的数组呢">2.为什么无法直接把字符串常量赋给一个的数组呢？</h2>
<p>字符串常量的的指针值是一个常量指针，数组名的值是也是一个指针常量，看似可以直接将字符串常量的值直接赋给数组名，但是如果这样操作实际上就丧了数组本身的意义，只是单单的把数组名这个指针指向了另一个地方，只是利用了数组的第一个元素的存储空间，而在声明数组时分配的存储空间就没有被使用，所以实际上我们想实现的不是把数组名指向字符串常量的地方，而是想使用数组的空间来复制字符串常量。</p>
<p>看下面两个例子：</p>
<pre><code class="language-c">/*example_1*/
char *message = &quot;123456&quot;;
char message1[] = message;
/*example_2*/
char message2[] = &quot;123456&quot;;
/*example_3*/
char message3[] = {'1','2','3','4','5','6','\0'};
</code></pre>
<p>这里example_1是错误的，example_2是正确的。显然example_1是上述所说的，不能直接把字符串常量赋给一个数组。对于example_2看似也像是直接把字符串赋给了数组，看似和example_1是一样的，但是实际上直接由于数组从一声明就具分配了空间，所以它是直接将这几个字符放在数组的连续存储空间中的，等效于example_3，它本来也是example_3的缩写。所以这里在初始化一个字符数组的时候，其后面实际不是一个字符串常量，而只是初始化数组时的初始化列表是的虽然它的形式是一样的，但是在其他的地方，例如这种形式的&quot;xxxxx&quot;就是表示字符串常量。</p>
<h2 id="3为什么无法修改数组名">3.为什么无法修改数组名？</h2>
<p>数组名的值是一个指针常量，同时也是数组名第一个元素的地址，它的类型，取决于其数组元素的类型。指针常量是由于在程序链接完成后数组的地址就已经固定了，是不能修改了，所以数组名也是无法修改的，所以其指向的也是指针产量。所以不能直接对数组名进行自增的操作。</p>
<p>可以把数组名指针常量提前赋给一个指针变量，通过指针变量修改作者常量。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 关于linux-86汇编函数的堆栈初始化和出栈入栈的理解]]></title>
        <id>https://yvainefire.github.io/post/guan-yu-linux-86-hui-bian-han-shu-de-dui-zhan-chu-shi-hua-he-chu-zhan-ru-zhan-de-li-jie/</id>
        <link href="https://yvainefire.github.io/post/guan-yu-linux-86-hui-bian-han-shu-de-dui-zhan-chu-shi-hua-he-chu-zhan-ru-zhan-de-li-jie/">
        </link>
        <updated>2021-05-13T08:19:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1一个只含返回语句main函数为空的代码段">1.一个只含返回语句main函数为空的代码段</h2>
<p>c语言代码</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
        return 0;
}

</code></pre>
<p>汇编代码</p>
<pre><code class="language-汇编">Disassembly of section .text:

0000000000000000 &lt;main&gt;:
   0:   55                      push   %rbp  
   1:   48 89 e5                mov    %rsp,%rbp
   4:   b8 00 00 00 00          mov    $0x0,%eax
   9:   5d                      pop    %rbp
   a:   c3                      retq   

</code></pre>
<p>分析：</p>
<p><strong>pop和push都是以rsp为堆栈指针</strong></p>
<p>0：将rbp指针入栈，进入以rsp为栈顶的栈，由于x86的栈是从高地址到低地址，所以rsp-8</p>
<p>1：将rsp这个栈顶指针赋给rbp，使rbp能够代替rsp进行出栈入栈的操作，而rsp保持在原来的栈底的位置，也相当于为rbp分配了一段新的栈，实际上仍然是rsp原来的栈。</p>
<p>4：return 0</p>
<p>9：利用rsp来恢复rbp最开始的值</p>
<h2 id="2含有一些变量的main函数">2.含有一些变量的main函数</h2>
<p>c语言代码</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int G = 111;
int l;

int main(void)
{
        int a = 0;
        int b;
        int c = 10;
        int C = 100;
        static int d = 1;
        static int e = 0;

        return 0;
}

</code></pre>
<p>汇编代码</p>
<pre><code class="language-汇编">Disassembly of section .text:

0000000000000000 &lt;main&gt;:
   0:   55                      push   %rbp
   1:   48 89 e5                mov    %rsp,%rbp
   4:   c7 45 f4 00 00 00 00    movl   $0x0,-0xc(%rbp)
   b:   c7 45 f8 0a 00 00 00    movl   $0xa,-0x8(%rbp)
  12:   c7 45 fc 64 00 00 00    movl   $0x64,-0x4(%rbp)
  19:   b8 00 00 00 00          mov    $0x0,%eax
  1e:   5d                      pop    %rbp
  1f:   c3                      retq   

</code></pre>
<p>分析：</p>
<p>main函数中含有未初始化的局部变量和静态局部变量，初始化的局部变量和静态局部变量，未初始化的全局变量和初始化的全局变量。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言 隐式转换]]></title>
        <id>https://yvainefire.github.io/post/yin-shi-zhuan-huan/</id>
        <link href="https://yvainefire.github.io/post/yin-shi-zhuan-huan/">
        </link>
        <updated>2021-05-13T08:18:33.000Z</updated>
        <content type="html"><![CDATA[<p>隐式转换的四种类型</p>
<h2 id="1算术运算中低类型能够转换为高类型">1.算术运算中低类型能够转换为高类型</h2>
<p>整型提升：即char转short，short转int，float转double</p>
<h2 id="2赋值表达式中右边表达式自动转换为左边表达式的类型">2.赋值表达式中，右边表达式自动转换为左边表达式的类型</h2>
<h2 id="3函数调用中参数传递时系统隐式的将实参的类型转换为形参的类型">3.函数调用中参数传递时，系统隐式的将实参的类型转换为形参的类型</h2>
<h2 id="4函数有返回值时系统隐式的将返回表达式类型转换为返回值类型赋值给调用函数">4.函数有返回值时，系统隐式的将返回表达式类型转换为返回值类型，赋值给调用函数。</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言 数组和指针]]></title>
        <id>https://yvainefire.github.io/post/c-yu-yan-shu-zu-he-zhi-zhen/</id>
        <link href="https://yvainefire.github.io/post/c-yu-yan-shu-zu-he-zhi-zhen/">
        </link>
        <updated>2021-05-13T08:17:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一维数组">一维数组</h2>
<p>数组名的值是一个<strong>指针常量</strong>，也就是该数组中第一个元素的地址。具体的类型是由该数组中元素的类型决定。例：如果数组的元素类型是int，则该数组名的类型是“指向int的常量指针”。</p>
<pre><code>由于数组名是一个指针常量，所以是不能修改数组名的。这样做的原因：再链接过后，该数组在内存中的位置就固定了，即数组名的值也就固定了，修改这个值，并不会把整个数组移动到另一个位置，所以禁止这样的操作。
</code></pre>
<p>数组具有确定数量的元素，而指针只是一个标量值。</p>
<h3 id="数组的初始化">数组的初始化</h3>
<p>完全初始化：在定义是指定每一个值；使用循环为每个下标初始化。</p>
<p>未完全初始化：定义时只指定前n个值，其余部分默认为0</p>
<p>完全为初始化：全部默认为0</p>
<h3 id="下标引用">下标引用</h3>
<p>下标引用和间接引用除了优先级的差别外，其他的效果一样。同时，任意的指针都可以和数组一样使用下标引用。例：</p>
<pre><code class="language-c">int array[10];
int *ap = array;
ap[0]=3;
</code></pre>
<p>负值下标：负值下标指的是该数组名对应的前一个地址的值。在使用负值下标时，一定要在有意思不会造成危险的时候进行使用，即一定要知道这个值不是非法的内存区。</p>
<h3 id="指针和下标">指针和下标</h3>
<p>虽然指针和下标可以任意的使用，但是在某些时候使用指针时的效率会更加的好一点。</p>
<p>例：两种方式对数组的每个元素进行遍历</p>
<pre><code class="language-c">//采用下标的形式
int array1[10],a1;
for(a1 = 0; a1 &lt; 10; a1++)
	array1[a1] = 0;
	
//采用指针的形式
int array2[10],a2;
for(a2 = array2; a2 &lt; array2 + 10; a2++)
	*a2 = 0;
</code></pre>
<p>对于第一种形式：每次使用一个乘法运算a*4（数据长度）计算相对与基址的相对地址。所以会有大量的乘法运算</p>
<p>对于第二种形式：由于是相当于一种累加的结果，所以只需要在编译的时候计算出1*4（数据长度），每次只进行一个加法运算a2+4。</p>
<p>对于数组模式的取值和指针模式的取值，</p>
<h3 id="数组名作为的函数参数">数组名作为的函数参数</h3>
<p>c语言的函数的参数是按值传送的，所以实际上就是一个拷贝，在一般的情况下是不会改变实参的。但是在数组做为参数传递进去的时候数组里面的内容可以改变，看似进行的是传址调用。</p>
<p>​		在数组名作为函数参数进行传送的时候，实际上实参就是一个指向数组第一个元素的指针，也就是数组第一元素的地址。所以实参拷贝给形参，形参的值就是数组第一个元素的地址，这个地址是不会被改变的，改变只可能是这个地址存储的内容，所以这也是按值传递。</p>
<p>同时这也说明了，函数不能根据数组名去获得数组的长度，需要额外的给出。</p>
<p>为了体现数组名作为参数的本质，<strong>最好将写为指针的形式</strong></p>
<h3 id="初始化">初始化</h3>
<p>自动（动态）变量和静态变量</p>
<ul>
<li>
<p>自动变量指（auto）：对于所有未特别指定的局部变量都是自动变量。当自动变量所在的作用域被执行完后会自动销毁该变量，同时每次执行声明该变量的代码都会<strong>创建一个新的变量</strong>分配相应的存储空间，每次的存储空间可能是不相同的。<strong>存放于栈（注意不是堆，堆是被malloc动态分配的变量的存储位置）中，在每次调用的时候会进行重新赋值。</strong></p>
</li>
<li>
<p>静态变量（static）：对于使用了static声明的局部变量变量是静态变量（<strong>注意全局变量是默认的static声明</strong>）。且即使静态变量所在的作用域被执行完了，该变量也不会被销毁而会存在于程序的整个执行中，且在下次重新执行到这段代码是会使用原来的这个变量。<strong>存放在静态存储区中，在编译就进行赋值了。</strong></p>
</li>
</ul>
<p><strong>注意是否需要被重新初始化和大数组初始化的时间</strong></p>
<p>数组的初始化需要看是自动的变量的初始化还是静态变量的初始化，且还需考虑是完整初始化，还是不完整初始化。当不完整初始化时都会将其默认为0或'\0'。</p>
<h2 id="多维数组">多维数组</h2>
<h3 id="数组名">数组名</h3>
<p>多维数组的数组名是指向其第一维数组的指针。所以实际上是指向指针的指针。</p>
<p>例如二维数组：int matrix[3] [4]</p>
<p>可将其看作是一个含有3个元素的1维数组，每1维元素为包含4个元素的向量。所有matrix是指向第一维数组的指针，*matrix相当于第一维数组的数组名，**matrix相当于第一维数组的第一个元素。</p>
<p>*(matrix+n)是第n维数组的数组名,**(matrix+n)是第n行的第一个元素。</p>
<p>*( *(matrix+n)+m)是第n行第m个元素</p>
<h3 id="指向二维数组的指针">指向二维数组的指针</h3>
<p>int (*p)[n]</p>
<p>声明一个第一维为n个元素的数组。实质上就是声明了一个整型的指针数组。对于这个数组来说其中的每个元素为一个指针，指向一个数组。</p>
<p>int (*m)[3] = matrix;</p>
<h3 id="数组名作为函数的参数">数组名作为函数的参数</h3>
<p>传入值为一个指向指针的指针。</p>
<h3 id="初始化-2">初始化</h3>
<p>两种方式：</p>
<p>int matrix[3] [4]={1, 1, 1,1, 1, 1,1, 1, 1,1, 1, 1};</p>
<p>int matrix[3] [4]={</p>
<p>{1, 1, 1}</p>
<p>{1, 1, 1}</p>
<p>{1, 1, 1}</p>
<p>{1, 1, 1}</p>
<p>};</p>
<p><strong>在二维数组中只有第一维能够根据初始化列表缺省地提供。</strong></p>
<h2 id="指针数组">指针数组</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[存储器]]></title>
        <id>https://yvainefire.github.io/post/cun-chu-qi/</id>
        <link href="https://yvainefire.github.io/post/cun-chu-qi/">
        </link>
        <updated>2021-05-13T08:13:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="ram">RAM</h2>
<p>随机存储器，随机指可读可写，且读取内部任意地址的时间是相同的。断电数据会丢失。</p>
<h3 id="dram">DRAM</h3>
<p>动态随机存储器，存储单元以电容的电荷来表示，动态指需要定期刷新。</p>
<p>一般用于CPU外部的扩展内存</p>
<h3 id="sram">SRAM</h3>
<p>静态随机存储器，以锁存器来存储数据，不需要定时刷新，但是断电数据还是会丢失。</p>
<p>一般只用于CPU内部的Cache</p>
<h2 id="非易失存储器">非易失存储器</h2>
<p>掉电后数据不会丢失。</p>
<h3 id="rom">ROM</h3>
<p>原指只读存储器，但现在指代非易失性半导体存储器，即掉电后数据不会丢失。包含只能读的存储器和可读但需要特殊写的存储器。</p>
<h3 id="flash">FLASH</h3>
<p>又称闪存，是可重读擦写的存储器。</p>
<p>FLASH根据内部“地址/数据线”是分开可以分为NAND FLASH 和 NOR FLASH。</p>
<h4 id="nor-flash">NOR FLASH</h4>
<p>NOR FLASH 的地址和数据线分开，可以按照字节读写数据，符合CPU的取指令的规则，所以如果CPU知道NOR FLASH上指令的地址，就可以直接执行。一般存储代码。</p>
<h4 id="nand-flash">NAND FLASH</h4>
<p>NAND FLASH 的地址和数据线是共用的，所以只能按照块来读写，所以CPU不能直接执行NAND FLASH 上的指令。需要先将NAND FLASH上的指令加载到RAM上面才能被CPU执行。一般存储数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FreeROTS 多优先级]]></title>
        <id>https://yvainefire.github.io/post/freerots-duo-you-xian-ji/</id>
        <link href="https://yvainefire.github.io/post/freerots-duo-you-xian-ji/">
        </link>
        <updated>2021-05-12T08:46:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="freertos优先级概述">FreeRTOS优先级概述</h2>
<p>虽然FreeRTOS支持同一优先级下可以有多个任务，但是此时我们假设每个优先级下最多有一个任务。</p>
<p>在FreeRTOS中优先级数字越小对应的优先级就越小。</p>
<p>FreeRTOS提供了两种方法用于优先级的查找，一种是通用的方法，一种是优化的方法。</p>
<h2 id="寻找最高优先级的任务">寻找最高优先级的任务</h2>
<h3 id="通用方法">通用方法</h3>
<p>提供当前就绪任务的优先级，把它和当前任务的优先级进行比较，判断是否跟新。再使用循环从当前最高任务的优先级对应的就绪队列中依次向下寻找若该就绪队列为空，就将当前最高任务的优先级自减，直到找到为止。</p>
<p>缺点：显然这样的查找方式并不能保证时间的确定性。</p>
<h3 id="优化方法">优化方法</h3>
<p>使用了前导零指令CLZ</p>
<p>CLZ指令是cortex-M提供的一条特殊的指令，计算一个32位的变量的从最高位开始计算第一个出现1位前面出现了0位的个数，即 CLZ(0xfffffff1) 等于31。</p>
<p>为了能使用前导零指令，需要更改使用优先级的方法，使用一个32位的变量uxTopReadyPriority作为位图，即第几个位上是1则表示这个位的数值对于的优先级的就绪列表上有任务就绪。如：0xfffffff3，表示优先级0和优先级1对应的就绪任务队列上有就绪的任务 。</p>
<p>根据uxTopReadyPriority来确定当前最高优先级的任务的优先级，使用CLZ指令一步计算即可。</p>
<p>当前最高优先级 =  31 - CLZ(uxTopReadyPriority)</p>
<p>优点： 可以保证时间的确定性</p>
<p>缺点：最大优先级为32</p>
<h2 id="时间片">时间片</h2>
<p>同一个优先级下可以有多个任务</p>
<p>如何实现同一优先级下任务的切换？</p>
<p>这主要是通过链表的头节点里面的 pxIndex来实现的，这个pxIndex在每次taskSELECT_HIGHEST_PRIORITY_TASK()选择最高优先级这个函数中中，通过listGET_OWNER_OF_NEXT_ENTRY()这个函数讲就绪列表的表头的索引指针pxIndex每次往后指一个，就实现了同一优先级的任务的切换在每个system sick后进行切换。</p>
<pre><code class="language-c">typedef struct xLIST
{
	/* the number of the Item for the list */
	UBaseType_t uxNumberOfItems; 
	
	ListItem_t * pxIndex;
	/* the end node for the list */
	MiniListItem_t xListEnd; 

}List_t;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FreeRTOS 任务延时列表的原理]]></title>
        <id>https://yvainefire.github.io/post/ren-wu-yan-shi-lie-biao-de-yuan-li/</id>
        <link href="https://yvainefire.github.io/post/ren-wu-yan-shi-lie-biao-de-yuan-li/">
        </link>
        <updated>2021-05-11T08:45:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="延时列表的结构">延时列表的结构</h2>
<p>任务延时列表是是一个双向链表，<strong>按照延时到达的时刻进行增序插入链表</strong>（这个是一个时段，而不是延时的时间，由开始延时的时刻加上延时的时间计算出来的时刻）。</p>
<p>需要维护</p>
<ul>
<li>全局变量系统从一开始到现在的系统时基计算器xTickCount</li>
<li>全局变量xNextTaskUnblockTime</li>
<li>两个任务延时列表，一个用于延时时刻变量溢出的任务，一个用于非溢出任务。</li>
</ul>
<h2 id="时基计时器和延时时刻的溢出">时基计时器和延时时刻的溢出</h2>
<p>需要注意系统时基计时器的值加上任务的延时值和时基计时器的值，是否会溢出，溢出了需要将这个任务插入另一条针对于溢出任务的延时列表，没有溢出的则正常插入到正常任务的延时列表。</p>
<p>溢出是实际上针对系统时基计数器这个变量（32位）而言的，当它的值变为0就表示溢出了。通过指针的切换来达到两个表的切换，实现溢出和非溢出延时队列的切换，同时系统时基计数器的归0，之后新的任务又会放在正确的表中。</p>
<h2 id="判断任务结束">判断任务结束</h2>
<p>利用系统时基计数器的值与结算任务的更新值来判断任务的延时是否结束。</p>
<p>系统时基xTickCount == 下一任务跟新解锁变量xNextTaskUnblockTime，任务延时结束。</p>
<p>优点：不需要扫描延时队列，只需要只是与xNextTaskUnblockTime这个全局变量进行比较。</p>
]]></content>
    </entry>
</feed>