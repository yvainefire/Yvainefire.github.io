<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yvainefire.github.io</id>
    <title>YvaineFire_block</title>
    <updated>2021-05-12T09:41:59.206Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yvainefire.github.io"/>
    <link rel="self" href="https://yvainefire.github.io/atom.xml"/>
    <subtitle>Rush Rush B</subtitle>
    <logo>https://yvainefire.github.io/images/avatar.png</logo>
    <icon>https://yvainefire.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, YvaineFire_block</rights>
    <entry>
        <title type="html"><![CDATA[FreeROTS 多优先级]]></title>
        <id>https://yvainefire.github.io/post/freerots-duo-you-xian-ji/</id>
        <link href="https://yvainefire.github.io/post/freerots-duo-you-xian-ji/">
        </link>
        <updated>2021-05-12T08:46:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="freertos优先级概述">FreeRTOS优先级概述</h2>
<p>虽然FreeRTOS支持同一优先级下可以有多个任务，但是此时我们假设每个优先级下最多有一个任务。</p>
<p>在FreeRTOS中优先级数字越小对应的优先级就越小。</p>
<p>FreeRTOS提供了两种方法用于优先级的查找，一种是通用的方法，一种是优化的方法。</p>
<h2 id="寻找最高优先级的任务">寻找最高优先级的任务</h2>
<h3 id="通用方法">通用方法</h3>
<p>提供当前就绪任务的优先级，把它和当前任务的优先级进行比较，判断是否跟新。再使用循环从当前最高任务的优先级对应的就绪队列中依次向下寻找若该就绪队列为空，就将当前最高任务的优先级自减，直到找到为止。</p>
<p>缺点：显然这样的查找方式并不能保证时间的确定性。</p>
<h3 id="优化方法">优化方法</h3>
<p>使用了前导零指令CLZ</p>
<p>CLZ指令是cortex-M提供的一条特殊的指令，计算一个32位的变量的从最高位开始计算第一个出现1位前面出现了0位的个数，即 CLZ(0xfffffff1) 等于31。</p>
<p>为了能使用前导零指令，需要更改使用优先级的方法，使用一个32位的变量uxTopReadyPriority作为位图，即第几个位上是1则表示这个位的数值对于的优先级的就绪列表上有任务就绪。如：0xfffffff3，表示优先级0和优先级1对应的就绪任务队列上有就绪的任务 。</p>
<p>根据uxTopReadyPriority来确定当前最高优先级的任务的优先级，使用CLZ指令一步计算即可。</p>
<p>当前最高优先级 =  31 - CLZ(uxTopReadyPriority)</p>
<p>优点： 可以保证时间的确定性</p>
<p>缺点：最大优先级为32</p>
<h2 id="时间片">时间片</h2>
<p>同一个优先级下可以有多个任务</p>
<p>如何实现同一优先级下任务的切换？</p>
<p>这主要是通过链表的头节点里面的 pxIndex来实现的，这个pxIndex在每次taskSELECT_HIGHEST_PRIORITY_TASK()选择最高优先级这个函数中中，通过listGET_OWNER_OF_NEXT_ENTRY()这个函数讲就绪列表的表头的索引指针pxIndex每次往后指一个，就实现了同一优先级的任务的切换在每个system sick后进行切换。</p>
<pre><code class="language-c">typedef struct xLIST
{
	/* the number of the Item for the list */
	UBaseType_t uxNumberOfItems; 
	
	ListItem_t * pxIndex;
	/* the end node for the list */
	MiniListItem_t xListEnd; 

}List_t;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FreeRTOS 任务延时列表的原理]]></title>
        <id>https://yvainefire.github.io/post/ren-wu-yan-shi-lie-biao-de-yuan-li/</id>
        <link href="https://yvainefire.github.io/post/ren-wu-yan-shi-lie-biao-de-yuan-li/">
        </link>
        <updated>2021-05-11T08:45:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="延时列表的结构">延时列表的结构</h2>
<p>任务延时列表是是一个双向链表，<strong>按照延时到达的时刻进行增序插入链表</strong>（这个是一个时段，而不是延时的时间，由开始延时的时刻加上延时的时间计算出来的时刻）。</p>
<p>需要维护</p>
<ul>
<li>全局变量系统从一开始到现在的系统时基计算器xTickCount</li>
<li>全局变量xNextTaskUnblockTime</li>
<li>两个任务延时列表，一个用于延时时刻变量溢出的任务，一个用于非溢出任务。</li>
</ul>
<h2 id="时基计时器和延时时刻的溢出">时基计时器和延时时刻的溢出</h2>
<p>需要注意系统时基计时器的值加上任务的延时值和时基计时器的值，是否会溢出，溢出了需要将这个任务插入另一条针对于溢出任务的延时列表，没有溢出的则正常插入到正常任务的延时列表。</p>
<p>溢出是实际上针对系统时基计数器这个变量（32位）而言的，当它的值变为0就表示溢出了。通过指针的切换来达到两个表的切换，实现溢出和非溢出延时队列的切换，同时系统时基计数器的归0，之后新的任务又会放在正确的表中。</p>
<h2 id="判断任务结束">判断任务结束</h2>
<p>利用系统时基计数器的值与结算任务的更新值来判断任务的延时是否结束。</p>
<p>系统时基xTickCount == 下一任务跟新解锁变量xNextTaskUnblockTime，任务延时结束。</p>
<p>优点：不需要扫描延时队列，只需要只是与xNextTaskUnblockTime这个全局变量进行比较。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FreeRTOS 空闲任务与延时阻塞]]></title>
        <id>https://yvainefire.github.io/post/kong-xian-ren-wu-yu-yan-shi-zu-sai/</id>
        <link href="https://yvainefire.github.io/post/kong-xian-ren-wu-yu-yan-shi-zu-sai/">
        </link>
        <updated>2021-05-10T08:44:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="空闲任务">空闲任务</h2>
<p>当操作系统中没有其它的任务可以运行时，就会运行一个空闲任务。</p>
<p>注意空闲任务的优先级需要设置为最低。</p>
<h2 id="延时阻塞">延时阻塞</h2>
<p>当任务调用延时阻塞函数后会被剥夺CPU的使用权，待延时结束后才能被调度器重修调度。如果此时除了空闲任务外的所有任务都被阻塞了，则CPU执行空闲任务。</p>
<p>延时阻塞的任务：</p>
<ul>
<li>设置延时的时长</li>
<li>将该任务从就绪队列中删除</li>
<li>进行任务切换</li>
</ul>
<p>任务的切换所耗费的时间相对于延时而且是很短的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FreeRTOS  临界段的保护]]></title>
        <id>https://yvainefire.github.io/post/freertos-lin-jie-duan-de-bao-hu/</id>
        <link href="https://yvainefire.github.io/post/freertos-lin-jie-duan-de-bao-hu/">
        </link>
        <updated>2021-05-07T08:44:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="临界段定义">临界段定义</h2>
<p>临界段指一段在执行过程中不能被中断打断的代码段。</p>
<h2 id="发生的时机">发生的时机</h2>
<p>临界段被打断主要发生在系统的调度和外部中断。在freeRTOS里，系统调度的本质是PendSV中断。</p>
<h2 id="本质">本质</h2>
<p>所以临界段保护的本质就是对中断的开关。</p>
<h2 id="需要被作为临界段保护的内容">需要被作为临界段保护的内容</h2>
<h3 id="全局变量">全局变量</h3>
<p>被多个任务或系统内核共享的全局变量，在任务切换或内核抢占当前代码段执行行，该全局变量可能会被修改，以后再恢复当前代码时，该全局变量的值已经被改变了，执行的结果就可能会出错。</p>
<h2 id="cortexm对临界段进行保护的方法">Cortex—M对临界段进行保护的方法</h2>
<p>在 FreeRTOS 中，对于进出临界区都是通过开关中断来进行实现的。</p>
<p>使用CPS指令对PRIMASK, FAULTMASK, BASEPRI 这三个寄存器进行操作，以达到对中断控制的目的。</p>
<ul>
<li>PRIMASK：单比特，关闭除 NMI 和硬 FAULT其他的所以异常</li>
<li>FAULTMASK：单比特，关闭除 NMI 其他的所以异常</li>
<li>BASEPRI：9位，可定义被屏蔽优先级的阈值，大于等于该值的会被屏蔽</li>
</ul>
<p>在 FreeRTOS 中，对中断的开和关是通过操作 BASEPRI 寄存器来实现的</p>
<h2 id="关中断的方式">关中断的方式</h2>
<h3 id="不带返回值">不带返回值</h3>
<p>不带返回值的意思是：在往 BASEPRI 写入新的值的时候，不用先将 BASEPRI 的值保存起来。所以无法恢复原来的BASEPRI ，这就导致了原来的中断屏蔽状态被破环了，所以不能在中断中使用。默认写入191，高四位有效，即优先级大于等于11的都会被屏蔽。</p>
<h3 id="带返回值">带返回值</h3>
<p>带返回值的关中断函数：先将BASEPRI的值临时存储下来，再更新完BASEPRI 值后，使用函数返回的形式返回这个值。</p>
<h2 id="开中断">开中断</h2>
<h3 id="不带中断保护的开中断">不带中断保护的开中断</h3>
<p>对应不带返回参数的关中断，直接将BASEPRI的值设置为0，打开所有中断。</p>
<h3 id="带中断保护的开中断">带中断保护的开中断</h3>
<p>对应带返回参数的开中断，将存储的BASEPRI的值，恢复进去。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FreeRTOS 任务切换]]></title>
        <id>https://yvainefire.github.io/post/freertos-ren-wu-qie-huan/</id>
        <link href="https://yvainefire.github.io/post/freertos-ren-wu-qie-huan/">
        </link>
        <updated>2021-05-06T10:18:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="调用的第一个任务的汇编函数">调用的第一个任务的汇编函数</h2>
<p>使用SVC中断，从当前任务的TCB中找到其栈顶，然后将栈里面的数据恢复到CPU的寄存器中，最后返回。</p>
<p>调用SVC中断时，如果当响应异常时，当前的代码正在使用PSP，则压入 PSP，即使用线程堆栈；否则压入MSP，使用主堆栈。一旦进入了服务例程，就将一直使用 主堆栈。所以之前的那一状态的寄存器的值会被保存到MSP中，依次自动保存xPSR, PC, LR, R12以及 R3‐R0由硬件自动压入MSP的堆栈中。</p>
<p>进入异常服务程序后，LR的值会被自动赋予为新的特殊的EXC_RETURN，只有[3:0]的值有特殊含义，以决定异常返回时进入是线程模式还是handler模式，使用MSP还是PSP，使用ARM指令还是Thumb指令。</p>
<p>退出异常时，需要手动把这个EXC_RETURN值送往PC时（使用跳转指令），就会启动处理器的异常中断返回序列，进行寄存器值得自动恢复及NVIC的清楚等等。进而更改PC的值，从而改变取指令的地址从而，跳转到指定位置，继续执行。</p>
<h2 id="使用pendsv进行上下文切换">使用PendSV进行上下文切换</h2>
<h3 id="流程">流程</h3>
<ol>
<li>在线程模式下触发PendSV异常，当该异常被响应并执行中断服务程序之前，硬件自动将xPSR, PC, LR, R12以及 R3‐R0这几个寄存器的值保存到PSP指向的任务堆栈中，再更新PSP指针到相应的位置。</li>
<li>进入PendSV的中断服务程序后，将自动更改堆栈为MSP，R14的值也会被自动更改为一个EXC_RETURN的值。</li>
<li>手动进行要被替换的任务的r4-r11寄存器值的保存，如果具有浮点运算单元，还需要保存浮点运算单元对应的寄存器，这里需要手动指定为PSP堆栈指针，最后需要使用PSP来更新该任务TCB中的堆栈指针。</li>
<li>将R14暂存到SP堆栈中，即MSP堆栈中，避免接下来调用子函数进行确定新的任务时被覆盖掉，从而在最后退出异常时手动把这个EXC_RETURN值送往PC时出错。</li>
<li>调用子函数确定接下来的currentTCB，即找到即将要执行的新任务的TCB，并用其更新currentTCB。</li>
<li>从MSP堆栈中，恢复R14</li>
<li>利用currentTCB，找到新任务的堆栈指针的header，并使用header将堆栈中对应的值赋给r4-r11寄存器。最后更新psp为当新任务的堆栈指针。</li>
<li>使用bx r14，进行返回，触发异常返回序列。</li>
</ol>
<p>问题：在新任务的TCB中，并没有响应的更改其header for the stack，因为在任务执行的时，是不会使用这个stack的，在下次任务切换的时候，这个新任务做为被保存上下文的任务，再更新这个header for the stack。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FreeRTOS	任务]]></title>
        <id>https://yvainefire.github.io/post/freertos-ren-wu/</id>
        <link href="https://yvainefire.github.io/post/freertos-ren-wu/">
        </link>
        <updated>2021-05-06T10:17:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="任务控制块">任务控制块</h2>
<p>任务控制块TCB的结构</p>
<pre><code class="language-c">typedef struct tskTaskControlBlock
{
	volatile StackType_t *pxTopOfStack; /* define the pointer for the head of the stack*/
	
	ListItem_t xStateListItem; /* define the node for the task*/
	
	StackType_t *pxStack;	/* define the start address for the task*/
	
	char pcTaskName[configUSE_16_BIT_TICKS]; /* define the name string for a task*/
	
}tskTCB;
</code></pre>
<h2 id="任务的创建">任务的创建</h2>
<h3 id="任务创建的两种方式">任务创建的两种方式</h3>
<p>在FreeRTOS中任务的创建分为静态创建和动态创建。</p>
<ul>
<li>动态创建时，任务控制块和栈的内存是创建任务时动态分配的，任务删除时，内存可以删除。</li>
<li>静态创建时，任务控制块和栈的内存时事先定义好的，在任务删除后，该内存是不能被删除的。</li>
</ul>
<h3 id="创建过程">创建过程</h3>
<ul>
<li>xTaskCreate创建了一个新的TCB指针初始化部分的成员，并调用prvInitialiseNewTask进一步初始化这个TCB指针</li>
<li>prvInitialiseNewTask计算栈顶的位置，初始化TCB里面的LlistItem节点，并调用堆栈的初始化函数pxPortInitializeStack</li>
</ul>
<p><strong>关于堆栈过程中将任务的入口函数地址进行8bytes对齐的原因？</strong></p>
<h2 id="就绪队列">就绪队列</h2>
<p>就绪列表本质上是一个List_t类型（ListNode 的 Root节点）的数组。数组的下标对应了任务的优先级，同一优先级的任务统一插入到就绪列表的同一条链表中。</p>
<p>在使用就绪队列前，需要先对就绪队列里面的元素进行初始化，相当于初始化一些链表的Root节点(ListItem)。</p>
<p>每个任务创建之后需要将其插入其优先级对应的就绪队列中，等待被调度。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FreeRTOS ARM内核SVC 和 PendSV]]></title>
        <id>https://yvainefire.github.io/post/svc-he-pendsv/</id>
        <link href="https://yvainefire.github.io/post/svc-he-pendsv/">
        </link>
        <updated>2021-04-29T10:21:43.000Z</updated>
        <content type="html"><![CDATA[<p>SVC和PendSV多用于操作系统的开发之上，用于将硬件层和应用层分开。</p>
<h2 id="svc系统调用服务">SVC系统调用服务</h2>
<p>SVC是一种异常，对应一个特定的SVC异常服务程序。同时使用SVC系统调用服务的时候还需要一个对应的立即数充当系统调用号。根据这个立即数，去调用相应的系统服务函数以实现应用程序对底层硬件的间接调用。</p>
<p>特点：不能嵌套SVC调用，该异常必须被立即响应，若由于当前正在处理更高优先级的异常或其它的原因，则会产生一个硬件fault。</p>
<h2 id="pendsv可悬起的系统调用">PendSV可悬起的系统调用</h2>
<p>PendSV和SVC执行一样的功能，但是PendSV可以向普通的中断被悬起，缓期再进行执行。若触发PendSV异常后，其优先级不够，则将被悬起，缓期执行。</p>
<p>将PendSV的优先级的设置为最低，可以使得在进行中断处理的时候不进行上下文的切换，从而防止出现systick异常抢占IRQ，并执行上下文切换，导致IRQ被延迟执行，从而影响系统对中断响应的实时性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言 常量指针和指针常量]]></title>
        <id>https://yvainefire.github.io/post/c-yu-yan-chang-liang-zhi-zhen-he-zhi-zhen-chang-liang/</id>
        <link href="https://yvainefire.github.io/post/c-yu-yan-chang-liang-zhi-zhen-he-zhi-zhen-chang-liang/">
        </link>
        <updated>2021-04-27T10:52:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常量指针">常量指针</h2>
<p>指针指向的内容是常量，用这个常量指针无法改变指针指向的内容，但是可以用另一个指向相同地址的非常量指针去改变他们共同指向的内容。</p>
<pre><code class="language-c">int A = 1;
int B = 2;
const int * C = &amp;A; //定义一个常量指针
int const * B = &amp;A; //定义一个常量指针
</code></pre>
<h2 id="指针常量">指针常量</h2>
<p>指针常量是指这个指针是一个常量，即不能将这个指针指向其它的地址，即不能改变这个指针本身。</p>
<pre><code class="language-c">int A = 1;
int B = 2;
int * const n =&amp;A; //定义一个指针常量
</code></pre>
<p><strong>注：区分常量指针和指针常量，可以通过const在 * 的左边还是右边。</strong></p>
<h2 id="常量指针常量">常量指针常量</h2>
<p>同时具有常量指针和指针常量的特点，既无法修改指针指向的内容也无法修改指针本身。</p>
<pre><code class="language-c">int A = 1;
const int * const C = &amp;A;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FreeRTOS	内核链表和链表项]]></title>
        <id>https://yvainefire.github.io/post/freertos-nei-he-lian-biao-he-lian-biao-xiang/</id>
        <link href="https://yvainefire.github.io/post/freertos-nei-he-lian-biao-he-lian-biao-xiang/">
        </link>
        <updated>2021-04-23T08:50:40.000Z</updated>
        <content type="html"><![CDATA[<p>FreeRTOS的链表是一个首尾相连的循环链表</p>
<p>链表的的每个节点被称为链表项，链表的根节点单独定义。同时对于每个链表项有两种定义方式，一种是完整的定义方式，一种是精简的定义方式。</p>
<p>注意是一个循环链表，所以链表的头节点也可以看作是链表的尾节点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FreeRTOS 裸机系统和多任务系统]]></title>
        <id>https://yvainefire.github.io/post/luo-ji-xi-tong-he-duo-ren-wu-xi-tong/</id>
        <link href="https://yvainefire.github.io/post/luo-ji-xi-tong-he-duo-ren-wu-xi-tong/">
        </link>
        <updated>2021-04-22T10:20:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="裸机系统">裸机系统</h2>
<p>裸机系统包括轮询系统和前后台系统</p>
<h3 id="轮询系统">轮询系统</h3>
<ul>
<li>结构：主程序是一个死循环，程序顺序执行。</li>
<li>响应和处理：外部事件由主程序进行响应，由主程序进行执行。</li>
<li>实时性：实时性较差。可能会导致事件的未被响应。轮询相应，轮询处理。</li>
</ul>
<h3 id="前后台系统">前后台系统</h3>
<ul>
<li>结构：在轮询系统的基础上加上了中断响应。前台响应中断并标记事件，如果处理的事件较简单则可以直接在中断中处理否则在后台中执行，后台为main函数里的无限循环，判断是否有事件被标记了并进行处理。</li>
<li>响应和处理：外部事件由中断响应，由中断或主程序处理</li>
<li>实时性：相比轮询系统，前后台系统确保了事件不会丢失。实时响应事件，但是只能轮询处理。</li>
</ul>
<h2 id="多任务系统">多任务系统</h2>
<ul>
<li>结构：在前后台系统的基础上，加入了任务的概念。任务是一个无限循环且不返回会的函数，各个任务之间相互独立，同时具备和中断一样的优先级，并由操作系统进行调度和管理。</li>
<li>响应和处理：外部事件由中断响应，由中断或任务处理</li>
<li>实时性：实时性可以很强。实时响应事件，并且实时处理事件。</li>
</ul>
<p><code>当一个紧急的事件在中断被标记之后，如果事件对应的任务的优先级足够高， 就会立马得到响应。</code></p>
]]></content>
    </entry>
</feed>