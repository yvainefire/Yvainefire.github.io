<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yvainefire.github.io</id>
    <title>YvaineFire_block</title>
    <updated>2020-10-23T08:23:39.468Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yvainefire.github.io"/>
    <link rel="self" href="https://yvainefire.github.io/atom.xml"/>
    <subtitle>Rush Rush</subtitle>
    <logo>https://yvainefire.github.io/images/avatar.png</logo>
    <icon>https://yvainefire.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, YvaineFire_block</rights>
    <entry>
        <title type="html"><![CDATA[Python的import]]></title>
        <id>https://yvainefire.github.io/post/python-de-import/</id>
        <link href="https://yvainefire.github.io/post/python-de-import/">
        </link>
        <updated>2020-10-23T08:22:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="几个基本的概念">几个基本的概念</h2>
<p>模块：一个.py文件就是一个模块。一个模块中可以有函数，类，变量。</p>
<p>包：一个包有一个子包或者一些模块组成。</p>
<p><strong><strong>init</strong></strong>.py: 暗示自己是一个包，一个包的结构</p>
<pre><code>sample_package / 
├──的__init__.py 
├──sample_module.py 
└──sample_module_import.py
	sample_package_son / 
	├──的__init__.py 
	├──son_sample_module.py 
	└──son_sample_module_import.py
</code></pre>
<h2 id="import的是什么">import的是什么</h2>
<p>引入的是包，引入的是包中的模块，引入的是模块中的方法</p>
<h2 id="import的内容从哪去找">import的内容从哪去找</h2>
<ul>
<li>
<p>sys.path目录下，sys.path也就是python的系统环境参数，该目录下具有一些系统自带的包，以及手动导入的包。不包含自己写的.py构成的模块。</p>
</li>
<li>
<p>当前运行的.py目录</p>
</li>
</ul>
<h2 id="几种import方式">几种import方式</h2>
<h3 id="import-moudle">import [moudle]</h3>
<p>引入整个包，但是直接使用import来引用当前目录下的模块（这里是实际上也是相对引用）可能会报错。因为虽然import会去sys.path目录或者运行文件所在的目录下去寻找，但是因为pycharm不会将当前文件目录自动加入自己的sourse_path。右键make_directory as--&gt;Sources Root将当前工作的文件夹加入source_path就可以了。</p>
<p>同时还需要注意在使用该模块中的方法的使，需要先给出这个moudle名。</p>
<p>eg:</p>
<pre><code class="language-python">#假设M中有一个method()方法
import M
M.method()

</code></pre>
<h3 id="from-module-import-name1-name2">from [module] import [name1, name2,.....]</h3>
<p>引入一个包或一个模块的部分内容，可以是一个包里的几个模块，也可以是一个模块中的几种方法。</p>
<h3 id="import-module-as-new_name">import [module] as [new_name]</h3>
<p>对于莫些方法或者模块的名字太长，使用的时候可以给一个别名。</p>
<p>eg：</p>
<pre><code class="language-python">import matplotlib.pyplot as pyplot
import numpy as np
</code></pre>
<h3 id="from-module-import">from [module] import *</h3>
<p>引入一个包或者一个模块中的所有内容，不建议这样做，因为可能会出现不同的模块中有相同的方法，可能就会造成名字冲突的现象出现。</p>
<h3 id="使用进行相对引用">使用.进行相对引用</h3>
<p>以上所说的基本上都是绝对查找，主要去使用sys.path下的包。python还支持相对当前运行环境目录下的相对产找。</p>
<pre><code class="language-python">.  		表示本级目录		 from . imprt xx
..  	表示上一级目录		from .. imprt xx
...		表示上两级目录		from ... imprt xx
以此类推

</code></pre>
<p>注意只能使用from [module] import的格式</p>
<h2 id="import陷阱">import陷阱</h2>
<p>循环import：两个.py互相引用对方文件里的内容</p>
<p>解决办法：引用整个module，而不引用单个方法</p>
<p>利用执行的时候才会检查是否存在，所以先引用这个module，因为module是必然存在的，至于这个module里的内容它是不会关心的。</p>
<p>参考：https://medium.com/pyladies-taiwan/python-%E7%9A%84-import-%E9%99%B7%E9%98%B1-3538e74f57e3</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 几种C/C++的编译器]]></title>
        <id>https://yvainefire.github.io/post/ji-chong-ccde-bian-yi-qi/</id>
        <link href="https://yvainefire.github.io/post/ji-chong-ccde-bian-yi-qi/">
        </link>
        <updated>2020-10-22T09:22:22.000Z</updated>
        <content type="html"><![CDATA[<p>操作系统封住一些可向外提供的函数形成函数库，并提供相应的API，供应用软件调用。库函数通常由一个或多个链接文件的形式提供。然而对于不同的操作系统可能具有不同的库函数，特别是C标准库。</p>
<p>POSIX标准主要就是针对<a href="https://link.zhihu.com/?target=http%3A//www.unix.org/apis.html">UNIX API</a>而制订，<strong>不管函数如何包装、功能如何实现，但API按照标准约定来（比如函数变量等符号名称、数据结构、参数类型与个数、基本工具命令名称等）</strong>，Linux完全兼容POSIX标准（部分函数符合POSIX，部分函数是Linux专有，即是POSIX的超集），微软声称Windows部分兼容POSIX标准。</p>
<h2 id="gcc">GCC</h2>
<p>GCC原名GNU C Complier,开始是针对C语言进行编译，后来发展为支持多种语言编译（C++、Fortran、Pascal、Objective-C、Java、Ada、Go等），所以又叫GNU Complier Collection。</p>
<p>类Unix下的标准编译器，支持多种语言，但是不能直接在Windows下使用。</p>
<h2 id="mingw">MingW</h2>
<p>MinGw 是Minimalistic GNU for Windows的缩写，也就是Windows版的GCC。</p>
<p>实现方式：具有以W32api的头文件，把Iinux下的系统调用替换为对应的Windows下的系统调用。</p>
<h2 id="cygwin">Cygwin</h2>
<p>Cygwin是一个在windows平台上运行的类UNIX模拟环境</p>
<p>Cygwin就是在Windows中增加了一个中间层——兼容POSIX的模拟层。</p>
<p>实现方式:</p>
<ul>
<li>
<p>采用cygwin1.dll，作为实现POSIX系统调用的模拟层，可原生运行在Windows中。</p>
</li>
<li>
<p>在cygwin1.dll之上构建的大量函数库、应用程序，如libc、zlib、bash、gcc、vim、awk、sed、git等等，与UNIX/Linux几乎等同*。</p>
</li>
</ul>
<p>Cygwin将cygwin1.dll、函数库、应用程序等文件按照UNIX/Linux的目录树架构进行组织存放，如/bin、/usr、/lib、/etc、/var、/home等等都存在于Cygwin安装路径下，用户从终端登陆进Cygwin的shell后，就可以像在UNIX/Linux系统那样使用相同的命令、工具</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/1603356418(1).png" alt="" loading="lazy"></figure>
<p><strong>Cygwin 生成的程序依然有 <code>fork()</code> 这样的 Linux 系统调用，但目标库是 cygwin1。而 MingW 生成的程序，则全部使用从 KERNEL32 导出的标准 Windows 系统 API。</strong></p>
<h2 id="llvmclang">LLVM+Clang</h2>
<p>LLVM 是模块化、可重用的编译器以及工具链技术的集合。LLVM不同的就是对于不同的语言它都提供了同一种中间表示（AST）。</p>
<p>Clang是LLVM项目下的一个子项目，基于LLVM架构的C/C++/Objective-C编译器前端</p>
<h2 id="msvc系列">MSVC系列</h2>
<p>微软自己写的编译器，与VS配套使用。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Windows_library_files%22%20%5Cl%20%22MSVCRT.DLL%2C_MSVCP*.DLL_and_CRTDLL.DLL">Microsoft C run-time library</a>(MSVCRT.DLL)，由微软随Windows发布，给Visual C++编辑器链接使用的</p>
<h2 id="嵌入式系统编译器">嵌入式系统编译器</h2>
<p>MDKzhe</p>
<p><a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/UClibc">μClibc</a>等，功能经过适度裁剪的C标准库，主要用在嵌入式系统</p>
<p>参考：https://zhuanlan.zhihu.com/p/57258281</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Ucosii的任务调度和优先级位图法]]></title>
        <id>https://yvainefire.github.io/post/ucosii-de-ren-wu-diao-du-he-you-xian-ji-wei-tu-fa/</id>
        <link href="https://yvainefire.github.io/post/ucosii-de-ren-wu-diao-du-he-you-xian-ji-wei-tu-fa/">
        </link>
        <updated>2020-08-25T13:13:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id=""></h1>
<h2 id="一osrdygrp和osrdytbl">一.OSRdyGrp和OSRdyTbl</h2>
<p>OS_EXT	INT8U	OSRdyGrp;</p>
<p>OS_EXT	INT8U	OSRdyTbl[OS_LOWESET_PRIO/8+1];</p>
<ol>
<li>
<p>可以看出里OSRdyGrp是一个8位的整型</p>
<p>将其表示为2进制，则可用每一位表示1个组的状态，即1或0，为1的实时表示这个组中至少有一个优先级有就绪任务，为0则表示没有。</p>
<p>实际上也可以把OSRdyGrp的每一位想成一个8进制数的第二位，即可能是0-7的任意一位。</p>
</li>
<li>
<p>OSRdyTbl[]是一个8位的整型数组，且其数组的元素的个数为除8再加1。</p>
<p>除8与8位整型对应，同样用一个8位的整型的2进制数来表示除以8这8个数，相当于压缩了。</p>
<p>每一个整型8位2进制数，其中为1的位表示当前位的优先级有就绪的任务。</p>
<p>也可以把这个数组的每一个元素的每一位2进制数看作是一个8进制数的第一位。</p>
</li>
</ol>
<p>综上OSRdyGrp相当于确定了类似十进制数的十位而OSRdyTbl[]相当于确定了类似十进制数的个位。</p>
<p>我们的目标是寻找已经就绪的最高优先级。即找到OSRdyGrp中第一个出现1的位相当于这里已经确定了十位，再找到确定了十位后在OSRdyTbl[十位]中最早出现1的个位。</p>
<p>如何确定这两个最早出现的位，同时又确保时间无关性？</p>
<p>如何用for循环直接去找的话没法做到时间的无关性的。</p>
<p>这里就必须引入一个优先级判定表</p>
<h2 id="二优先级判定表">二.优先级判定表</h2>
<pre><code class="language-c">INT8U  const  OSUnMapTbl[256] = {
    0u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x00 to 0x0F                   */
    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x10 to 0x1F                   */
    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x20 to 0x2F                   */
    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x30 to 0x3F                   */
    6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x40 to 0x4F                   */
    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x50 to 0x5F                   */
    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x60 to 0x6F                   */
    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x70 to 0x7F                   */
    7u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x80 to 0x8F                   */
    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x90 to 0x9F                   */
    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xA0 to 0xAF                   */
    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xB0 to 0xBF                   */
    6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xC0 to 0xCF                   */
    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xD0 to 0xDF                   */
    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xE0 to 0xEF                   */
    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u  /* 0xF0 to 0xFF                   */
};
</code></pre>
<p>数组共有256个元素其下标为0-255，表示一个8位2进制数所能表示的值。数组的每一个元素表示这个下标对应的10进制数的2进制表示形式中第一个出现1的位所在的位数。比如说下标为16的数，其二进制的表示形式为10000，所以最先出现1的位数是第4位，从上表中可以找到下标为16即0X10对于的元素为1u。</p>
<p>所以根据这个优先级表，可以在时间无关的限制下找到OSRdyGrp和OSRdyTbl[]最早出现1的位的位值。也就找到了当前最高优先级的值。</p>
<p>下一个问题就是如何把这两个值拼接为一个10进制数，因为优先级使用的时候都是以10进制数的形式去找到对应优先级的指针，即当前到调度的任务的指针。</p>
<p>前面已经说明可以将其看作一个8进制数，所以就是相当于把一个分别知道第一位A和第二位B的且只有两位的8进制数转换为一个10进制数。</p>
<p>A*8+B 使用位运算 = A &lt;&lt; 3 + B</p>
<p>转换为程序中的变量进行表示：</p>
<p>y = OSUnMapTbl[OSRdyGrp] &lt;&lt; 3</p>
<p>x = OSUnMapTbl[OSRdyTbl[y]]</p>
<p>优先级 = x + y</p>
<h2 id="三结合ucosii的运用优先级位图">三.结合ucosii的运用优先级位图</h2>
<p>1.把一个新创建的任务放入就绪队列</p>
<p>放入就绪队列的意义就是指把OSRdyTbl[]这个8位2进制整型数组的对应位置1，以表示该优先级有对应的任务就绪。</p>
<p>所以问题就是把这个任务原本具有的10进制的优先级在OSRdyTbl[]上体现出来，同时为了找到OSRdyTbl[]上的行，还必须使用OSRdyGrp，所以也需要更新OSRdyGrp。</p>
<p>OSRdyTbl[]这个数组本身就可以理解为一个2位的8进制数。实际上就是把任务的10进制数转换为2位的8进制数，并把8进制数的第一位和第二位分开，第二位用于确定行数，第一位用于确定列数。</p>
<p>在TCB的结构中有4个变量用来存储这两位,并在OSTCBInit()这个函数中为这几个变量赋值</p>
<pre><code class="language-c">ptcb-&gt;OSTCBY = (INT8U) (prio &gt;&gt; 3);//取第二组3位，分离8进制第二位
ptcb-&gt;OSTCBBitY = OSMapTbl[ptcb-&gt;OSTCBY];
ptcb-&gt;OSTCBX = (INT8U) (prio &amp; 0x07);//取第一组3位，分离8进制第一位
ptcb-&gt;OSTCBBitX = OSMapTbl[ptcb-&gt;OSTCBX];
</code></pre>
<p>bit是为了将这个分离出来的数用掩码表示即用8位二进制数每一位有且仅有1位为1的时候表示0-7（即7表示为10000000），为了方便对OSRdyGrp和OSRdyTbl[]直接使用位运算进行更新。</p>
<p>更新OSRdyGrp和OSRdyTbl[]的操作</p>
<pre><code class="language-c">OSRdyGrp |= ptcb-&gt;OSTCBBitY;
OSRdyTBl[ptcb-&gt;OSTCBY] |= ptcb-&gt;OSTCBBitX;
</code></pre>
<p>2.找到当前最高优先级的任务</p>
<p>所谓优先级最高的任务的调度，也就是要找到最高优先级，因为在ucosii中为了设计的简单和确保实时性，所以一个优先级只有有一个任务，即不可能有同样优先级的任务。所以找到了当前的最高优先级就找到了其对应的任务。</p>
<pre><code class="language-c">OS_SchedNew(){
	INT8U y;
	y = OSUnMapTbl[OSRdyGrp]; //找到行
	OSPrioHighRdy = y &lt;&lt; 8 + OSUnMapTbl[OSRdyGrp[y]];	

}
</code></pre>
<h2 id="四任务调度">四.任务调度</h2>
<p>任务调度的函数：</p>
<pre><code class="language-c">void  OS_Sched (void)
{
#if OS_CRITICAL_METHOD == 3u              /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0u;
#endif


    OS_ENTER_CRITICAL();
    if (OSIntNesting == 0u) {             /* Schedule only if all ISRs done and ...       */
        if (OSLockNesting == 0u) {                     /* ... scheduler is not locked     */
            OS_SchedNew();
            OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy   */
#if OS_TASK_PROFILE_EN &gt; 0u
                OSTCBHighRdy-&gt;OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task */
#endif
                OSCtxSwCtr++;             			/* Increment context switch counter   */
                OS_TASK_SW();                          /* Perform a context switch        */
            }
        }
    }
    OS_EXIT_CRITICAL();
}
</code></pre>
<p>任务调度不能发生在中断中</p>
<p>任务调度需要调度锁是开启状态</p>
<p>任务是否需要切换，最高优先级是否改变优先级</p>
<p>找到当前最高优先级的任务OS_SchedNew();</p>
<p>任务调度过程发生在临界区中</p>
<h2 id="五上下文的切换">五.上下文的切换</h2>
<p>上下文切换的目的就是CPU需要切换到另一个任务是需要保存当前任务的运行状态并恢复另一个任务的运行状态。</p>
<p>上下文切换分为：</p>
<ul>
<li>
<p>主动上下文切换：任务执行过程中自动挂起自己OSTaskSuspend()</p>
</li>
<li>
<p>被动上下文切换：又叫中断触发任务切换，是指在由于中断引起抢占当时正在执行的任务，保存正在执行的任务的运行信息并且在中断响应完之后重新进行调度，恢复当前优先级最高的任务引起的上文的切换。</p>
</li>
</ul>
<p>1.主动上下文切换</p>
<ul>
<li>
<p>保存当前正在执行的任务的运行信息</p>
<p>保存信息的顺序：</p>
<p>PC,LR,R12-R0,CPSR</p>
<p>注意当调用这个函数的时候，会自动把当前执行指令的地址PC下一条指令保存到LR，PC转为这个函数第一条指令的地址，所以保存要下一条指令的值即PC的值，只能通过保存链接寄存器LR的值来达到这一目的。</p>
<p>再保存LR这里实际上和第一个保存的PC的值是一样的，但是为什么要保持两次呢，因为只是在这种情况下这两个值是一样得。如果涉及到处理器运行状态的改变就可能不同了。</p>
<p>对于CPSR的处理，也要注意，只有MRS指令可以读CPSR，所以要先用MRS指令将其读到一个寄存器中，再将其放入 堆栈中。</p>
<pre><code class="language-c">
</code></pre>
</li>
<li>
<p>修改要运行的任务指针为最高优先级任务的指针</p>
<p>OSTCBCur = OSTCBHighRdy</p>
<pre><code class="language-c">
</code></pre>
</li>
<li>
<p>修改当前任务的优先级为最高优先级</p>
<p>OSPrioCur = OSPrioHighRdy</p>
<pre><code class="language-c">
</code></pre>
</li>
<li>
<p>修改当前的堆栈指针SP为当前最高优先级的任务的堆栈指针</p>
<p>OSPrioHighRdy这个结构体的第一个就是它的堆栈指针，所以也就是它的地址</p>
<p>SP = OSPrioHighRdy这个地址的值</p>
<pre><code class="language-c">
</code></pre>
</li>
<li>
<p>恢复当前最高优先级的任务的运行信息</p>
<p>注意出栈的顺序与入栈的顺寻相反</p>
<p>出栈的时候LR用于更新PC,同时还要恢复CPSR的值，即^符号</p>
<pre><code class="language-c">
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux套接字编程]]></title>
        <id>https://yvainefire.github.io/post/linux-tao-jie-zi-bian-cheng/</id>
        <link href="https://yvainefire.github.io/post/linux-tao-jie-zi-bian-cheng/">
        </link>
        <updated>2020-07-30T08:16:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一posix标准">一.POSIX标准</h2>
<p>POSIX表示可移植操作系统接口，是IEEE为各种UNIX操作系统上运行的软件定义的一系列API标准的总称。</p>
<h2 id="二socket基本概念">二.Socket基本概念</h2>
<ol>
<li>
<p>套接字：协议操作的接口，而非协议本身。应用层通过这个接口使用传输层提供的服务，进行接收和发送数据包。</p>
</li>
<li>
<p>主动套接字和被动套接字</p>
<p>主动套接字：发起连接的套接字</p>
<p>被动套接字：等待传入的套接字</p>
</li>
<li>
<p>套接字的基本类型</p>
<p>SOCKET_DGRAM：双向不可靠数据流</p>
<p>SOCKET_STREAM：双向可靠数据流</p>
<p>SOCKET_RAW：低级协议或为物联网络提供的套接字</p>
</li>
</ol>
<h2 id="三套接字的地址结构类型">三.套接字的地址结构类型</h2>
<ol>
<li>
<p>两种套接字</p>
<p>​	   a.通用套接字</p>
<pre><code class="language-c">struct sockaddr{
    unsigned short sa_family;/*地址族*/
    char sa_data[14];
};
</code></pre>
<p>​		b.ipv4套接字</p>
<pre><code class="language-c">struct sockaddr_in{    
    short int sin_family;/*地址族*/
    unsigned short int sin_port;/*端口号*/
    struct in_addr sin_addr;/*IP地址*/
    unsigned char sin_zero[8];/*零数据*/
}；
</code></pre>
<p>​		c.ipv6套接字</p>
<pre><code class="language-c">struct sockaddr_in6
</code></pre>
<p>地址族：决定了决定了套接字的种类</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/family.png" alt="" loading="lazy"></figure>
<p>通用套接字和特殊套接字之间可以进行相互的转换，这两种表现形式实际上是等价的。socketaddr_in用于用户设置的地址信息，sockaddr则用于作为bind,connet,recfvfrom等函数的参数。</p>
</li>
<li>
<p>地址转换函数</p>
<pre><code class="language-c">int inet_pton(int family,const char *src,void *dst);

const char *inet_ntop(int family,const void *src,char *dst,size_t cnt);
</code></pre>
<p>dst是指向struct in_addr或struct in6_addr 的指针，必须事先分配空间src是指向点分10进制的字符串指针</p>
</li>
</ol>
<h2 id="四几个重要的函数">四.几个重要的函数</h2>
<h3 id="1socket函数">1.socket函数</h3>
<p>int socket(int family,int type,int protocol)</p>
<p>作用：创建一个新的套接字</p>
<p>参数：</p>
<ul>
<li>
<p>family：网络协议族（IPV4,IPV6,UNIX）</p>
</li>
<li>
<p>type：协议类型 (字节流，数据报，有序分组套接字，原始套接字）</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/type.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>protocol：特定的协议类型（TCP,UDP,SCTP）</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/protocol.png" alt="" loading="lazy"></figure>
</li>
<li>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/relation.png" alt="" loading="lazy"></figure>
<p>UDP是数据报套接字</p>
<p>TCP是字节流套接字</p>
</li>
</ul>
<p>返回值：返回值为非负则说明申请一个套接字成功，出错返回-1</p>
<h3 id="2bind函数">2.bind函数</h3>
<p>int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);</p>
<p>作用：把套接字绑定在相应的ip和端口</p>
<p>参数：</p>
<ul>
<li>sockfd：开始创建的套接字描述符</li>
<li>myaddr：指向特定协议的地址结构指针，指本地地址和端口号</li>
<li>addrlen：地址长度</li>
</ul>
<p>对于客户机而言：绑定一个特定的IP就相当于为该套接字发送的IP数据报指定了源IP地址，但是这个IP应该是属于这个主机的某个端口。如果没有调用bind函数进行绑定，则内核会为相应的套接字选择一个临时的端口，常用于客户机上。</p>
<p>对于服务器而言：绑定一个特定的IP就限定了该套接字只接收那些客户机的IP数据报。</p>
<p><strong>绑定的具体含义</strong>：绑定涉及到三个对象，套接字，地址和端口。其中套接字是捆绑的主体，地址和端口是绑定在套接字上的客体。</p>
<p>返回值：成功返回0，出错返回-1</p>
<h3 id="3connect函数">3.connect函数</h3>
<p>int connect(int sockfd,const struct sockaddr *servaddr,socklen_t addrlen)</p>
<p>作用：客户机用connect函数来建立与TCP服务器的连接。</p>
<p>参数：</p>
<ul>
<li>sockfd：<strong>创建的套接字，这里可以是已绑定的，也可以是还未绑定的，未绑定的套接字，内核会自动为它进行分配相应的ip和端口号。</strong></li>
<li>servaddr：指向要建立连接的服务器的ip地址和端口号，这两个信息一般来说是周知的。</li>
<li>addrlen：地址的长度。</li>
</ul>
<p>返回值：成功返回0，出错返回-1</p>
<p>注意：当循环调用connect并尝试知道有一个成功的连接时，在每次connect失败后都必须closed掉当前的套接字描述符并重新调用socket。</p>
<h3 id="4listen函数">4.listen函数</h3>
<p>int listen (int sockfd,int backlog);</p>
<p>作用：把为建立连接的套接字转化为一个被动套接字，指示内核应接受指向该套接字的连接请求。在接收到客户机的SYN时在未连接的队列中创建一个新的单元，在三次握手完成后就将未连接的队列连接到已连接的队列，并返回1表示连接成功。listen函数总的来说就是做监听作用。</p>
<p>参数：</p>
<ul>
<li>sockfd：指示套接字的描述符</li>
<li>backlog：指定监听连接的数量，已连接的队列和未连接的队列之和不超过backlog的值。</li>
</ul>
<p>返回值：</p>
<p>成功返回0，出错返回-1</p>
<h3 id="5accept函数">5.accept函数</h3>
<p>int accept(int sockfd,struct sockaddr *<em>cliaddr,socklen_t</em> *addrlen);</p>
<p>作用：成功返回后，系统从完成队列中取出socket，为每个连接创建一个新的连接套接字，服务器只对新的连接使用该套接字，**原来的监听套接字仍然保留用作其它的连接请求。**其返回值是内核自动生成的一个全新的描述符。<strong>一个服务器通常只有一个监听套接字</strong>，内核为服务器的每个进程创建一个新的套接字用以保持连接，在连接结束后就会自动关闭这个连接套接字，而监听套接字在服务器的整个生命周期一直存在。</p>
<p>参数：</p>
<ul>
<li>
<p>sockfd：监听套接字的描述符，用于TCP协议</p>
</li>
<li>
<p>cliaddr：这个sockadd指针会在accept函数里面进行设置</p>
</li>
<li>
<p>addrlen：这个长度指针也会在accept函数里面进行设置</p>
</li>
</ul>
<p>返回值：</p>
<p>若成功则描述结果为非负也就是内核为接受的客服连接创建的一个已连接套接字，出错则为-1</p>
<p>关于accept函数listen函数及其维护的两个队列的相关说明</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/%E9%98%9F%E5%88%97.jpg" alt="" loading="lazy"></figure>
<p>TCP转换图：</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="" loading="lazy"></figure>
<p>在状态转换图中并未出现把未连接的套接字转换为被动套接字这个过程。</p>
<p>三次握手示意图：</p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/yvainefire/Picbed_PicGo/master/img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="" loading="lazy"></figure>
<p>三次握手的第一个SYN到达时，服务器为其分配缓存和等资源，然后回发SYN，随机生成的开始序号以及ACK并等待客户端的ACK，在客户端的ACK到来后表示三路握手完成。</p>
<p>具体说明：</p>
<p>用socket创建套接字后，它是一个未连接套接字这里创建的也就是用于监听的套接字，在主动调用listen函数后就把创建的这个套接字做监听使用也就是监听套接字，也就是前面所说的把一个未连接的套接字转换为了被动套接字，所以监听套接字实际上在这个时候就等于被动套接字。在三次握手的客户端的SYN到达时，就会把这个被动套接字（监听套接字）的信息自动复制（内核自动完成）一份到为完成的队列，然后监听套接字再去监听其它的连接，这个未完成的套接字就继续做三次握手剩下的内容。在完成三次握手后就把这一项从未完成队列转移到完成队列。</p>
<h3 id="6close函数">6.close函数</h3>
<p>int close(int sockfd)</p>
<p>作用：默认行为是关闭该套接字的，然后返回调用进程。</p>
<p>参数：</p>
<ul>
<li>套接字的描述符</li>
</ul>
<p>返回值：</p>
<p>若成功则返回0，出错返回-1</p>
<h3 id="7recv函数">7.recv函数</h3>
<p>ssize_t recv(int sockfd,void *buf,size_t len,int flags)</p>
<p>作用：从TCP接收数据，返回实际的数据长度，这里的sockfd里面包含了接收的数据的IP地址。如果只有一个进程使用，立即终止连接并撤销该套接字，如果多个进程共享该套接字，将引用数减一，如果引用数降到零，则撤销它。</p>
<p>参数：</p>
<ul>
<li>
<p>sockfd：套接字描述符</p>
</li>
<li>
<p>buf：接收数据的存放缓存，指向内存的指针</p>
</li>
<li>
<p>len：接收的数据的长度</p>
</li>
<li>
<p>flags：一般为0</p>
</li>
</ul>
<p>返回值：若成功则返回读的字数，出错返回-1</p>
<h3 id="8recvfrom函数">8.recvfrom函数</h3>
<p>ssize_t recvfrom(int sockfd,void *<em>buf,size_t len,int flags,struct sockaddr</em> *src_addr,socklen_t *addrlen)</p>
<p>作用：在UDP连接上发送数据，成功就返回数据的长度，由于UDP是为建立连接的，所以事先不知道数据是从哪发来的，所以这里需要额外的参数来保存接收数据的IP和端口号。</p>
<p>参数：</p>
<ul>
<li>
<p>sockfd：套接字描述符</p>
</li>
<li>
<p>buf：接收数据的存放缓存，指向内存的指针</p>
</li>
<li>
<p>len：接收的数据的长度</p>
</li>
<li>
<p>flags：一般为0</p>
</li>
<li>
<p>src_addr：保存远端的地址（发送方，对当前而言的接收方）即IP和端口号</p>
</li>
<li>
<p>addrlen：远端的地址的长度的指针</p>
</li>
</ul>
<p>返回值：若成功则返回读的字数，出错返回-1</p>
<h3 id="9send函数">9.send函数</h3>
<p>int send(int sockfd,const void *buf,size_t len,int flags)</p>
<p>作用：在TCP连接上发送数据，成功就返回数据的长度，所以这里也不需要额外指接收数据的IP和端口号，因为套接字描述符里面有绑定。</p>
<p>参数：</p>
<ul>
<li>
<p>sockfd：套接字描述符</p>
</li>
<li>
<p>buf：发送缓存</p>
</li>
<li>
<p>len：发送数据的长度</p>
</li>
<li>
<p>flags：一般为0</p>
</li>
</ul>
<p>返回值：若成功则返回写的字数，出错返回-1</p>
<h3 id="10sendto函数">10.sendto函数</h3>
<p>int sendto(int  sockfd,const void *<em>buf,size_t len,int flags,const struct sockaddr</em> *dest_addr,socklen_t addrlen)</p>
<p>作用：在UDP连接上发送数据，成功就返回数据的长度。因为UDP套接字里没有绑定发送的IP地址和端口号，所以这里需要额外指接收数据的IP和端口号。</p>
<p>参数：</p>
<ul>
<li>
<p>sockfd：套接字描述符</p>
</li>
<li>
<p>buf：发送缓存</p>
</li>
<li>
<p>len：发送数据的长度</p>
</li>
<li>
<p>flags：一般为0</p>
</li>
<li>
<p>dest_addr：发送的数据的地址，由前面的recform获得</p>
</li>
<li>
<p>addrlen：远端的地址的长度</p>
</li>
</ul>
<p>返回值：若成功则返回写的字数，出错返回-1</p>
<h2 id="五循环服务器udp编程">五.循环服务器UDP编程</h2>
<h3 id="1服务器端">1.服务器端</h3>
<ol>
<li>
<p>建立UDP套接字</p>
</li>
<li>
<p>绑定套接字到特定的地址（将套接字与对应的地址，端口号相关联）</p>
</li>
<li>
<p>等待并接收客户端的信息</p>
</li>
<li>
<p>处理客户端请求</p>
</li>
<li>
<p>发送信息回客户端</p>
</li>
<li>
<p>关闭套接字</p>
</li>
</ol>
<h3 id="2客户端">2.客户端</h3>
<ol>
<li>
<p>建立UDP套接字</p>
</li>
<li>
<p>发送信息给服务器</p>
</li>
<li>
<p>接收来自服务器的信息</p>
</li>
<li>
<p>关闭套接字</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多进程]]></title>
        <id>https://yvainefire.github.io/post/duo-jin-cheng/</id>
        <link href="https://yvainefire.github.io/post/duo-jin-cheng/">
        </link>
        <updated>2020-07-30T07:25:38.000Z</updated>
        <content type="html"><![CDATA[<p>#一. fork函数</p>
<h2 id="1关于fork函数">1.关于fork()函数</h2>
<p>pid_t fork(void);</p>
<p>创建一个新的进程，对于原进程而言该进程是子进程。</p>
<p>注意子进程和父进程的关系</p>
<h2 id="2关于返回值">2.关于返回值</h2>
<p>返回值有两个</p>
<p>对于子进程而言返回值为0</p>
<p>对于父进程而言，返回值是子进程的进程号</p>
<p><strong>为什么返回值会设置两个</strong>：因为对于一个父进程而言，是很难获得其子进程的进程号的，毕竟 一个父进程可能会有多个子进程。所以对于父进程而言，返回值设置其子进程的进程号，方便  父进程进行记录。而对于子进程而言，就很容易找到其父进程对应的进程号，使用getppid()函数。<br>
出错返回-1</p>
<h2 id="3关于拷贝">3.关于拷贝</h2>
<p>os会分配新的内存空间和内核数据结构给子进程</p>
<p>父进程中的部分代码，数据会拷贝到子进程中包括父进程的数据空间，堆，栈，还包括缓冲区的数据。这些拷贝的东西都是父本，所以是不会进行数据共享的，包括信号量。对于代码拷贝一定要注意：只拷贝位于fork()之后的代码，同时这里的拷贝不是真正的拷贝，只能说是代码的共享。这里特别注意循环结构，</p>
<p><strong>父子进程是相对的</strong>！！！！</p>
<p><strong>特别注意在带循环的进程创建的时候，在父进程创建子进程后，子进程拷贝的代码是for()位置当前未执行完的代码，即还需要考虑仍需执行的循环的次数。若该子进程会进行fork()创建对他而言的子进程，则在以此子进程为主进程的进程中，此子进程充当父进程。即父子进程是相对的额，是根据两进程的相对关系而言的。这里特别要注意，使用for进行fork()时一共创建的进程不是1+n个！！！</strong></p>
<p>两段代码：<br>
代码1</p>
<pre><code class="language-c">for(int i=0;i&lt;3;i++)  
{    
    if(pid=fork())    
    {      
        printf(&quot;%d\n&quot;,getpid());    
    }    
    else    
    {      
        printf(&quot;%d\n&quot;,getpid());    
    }      
}
</code></pre>
<p>代码2</p>
<pre><code class="language-c">int i=1;

  while((pid=fork()))    
  {            
      printf(&quot;pid:%d i:%d\n&quot;,getpid(),i);      
      if(i&gt;5)      
      {                  
          break;      
      }                      
      i++;        
  }    

printf(&quot;pid:%d\n&quot;,getpid());
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数指针]]></title>
        <id>https://yvainefire.github.io/post/han-shu-zhi-zhen/</id>
        <link href="https://yvainefire.github.io/post/han-shu-zhi-zhen/">
        </link>
        <updated>2020-07-30T07:07:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一函数指针和函数首地址">一.函数指针和函数首地址</h2>
<p>地址的联系</p>
<p>如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，<strong>这段存储空间的首地址称为这个函数的地址</strong>。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫<strong>作函数指针变量</strong>，简称函数指针。</p>
<h2 id="二函数指针的定义方式">二.函数指针的定义方式</h2>
<p>然而函数指针的定义和普通指针的定义事不同的。</p>
<p>函数指针的定义方式：</p>
<pre><code>函数返回值类型 (* 指针变量名) (函数参数列表);
</code></pre>
<p>例：</p>
<pre><code class="language-c"># include &lt;stdio.h&gt;
int Max(int, int);  //函数声明
int main(void){    
    int(*p)(int, int);  //定义一个函数指针    
    int a, b, c;    
    p = Max;  //把函数Max赋给指针变量p, 使p指向Max函数    
    
    printf(&quot;please enter a and b:&quot;);    
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);    
    c = (*p)(a, b);  //通过函数指针调用Max函数    
    printf(&quot;a = %d\nb = %d\nmax = %d\n&quot;, a, b, c);   
    
    return 0;
}
int Max(int x, int y)  //定义Max函数
{    
    int z;    
    if (x &gt; y) {        
        z = x;    
    }else 
    {        
        z = y;    
    }    
    return z;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对齐]]></title>
        <id>https://yvainefire.github.io/post/dui-qi/</id>
        <link href="https://yvainefire.github.io/post/dui-qi/">
        </link>
        <updated>2020-07-30T07:03:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一字节对齐的概念">一.字节对齐的概念</h2>
<p>计算机系统对基本数据类型的合法地址做了一些限制，这种限制称为对齐。</p>
<p>如：要求某些数据的地址只能以1或2或8或16的倍数。</p>
<h2 id="二字节对齐的原因">二.字节对齐的原因</h2>
<h3 id="1性能">1.性能</h3>
<p>字节对齐的根本原因在于提高数据的访问的效率。主要在于减少数据访问的次数，因为不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。如x86的一个总线周期只能访问偶地址的数据，所以若不进行对齐，一个原本可以一次访存获得的数据则需要2次甚至更多次才能得到。</p>
<h3 id="2平台原因">2.平台原因</h3>
<p>不是所有的硬件平台都能访问到任意地址上的任意数据</p>
<h2 id="三几种对齐的方式">三.几种对齐的方式</h2>
<h3 id="1数据类型自身的对齐自然对齐">1.数据类型自身的对齐(自然对齐)</h3>
<p>存放变量的地址为该变量在改平台上对应的数据类型大小的整数倍。</p>
<h3 id="2结构体或类的自身对齐">2.结构体或类的自身对齐</h3>
<p>结构体或类的首地址是其成员中自身对齐值最大的那个值的整数倍。</p>
<h3 id="3指定对齐值">3.指定对齐值</h3>
<p>#pragma pack (value)时的指定对齐值value。</p>
<p>例：#pragma pack (5)</p>
<p>int a = 4;</p>
<p>int b = 9;</p>
<p>即：按照5字节进行对齐</p>
<h3 id="4数据成员结构体和类的有效对齐值">4.数据成员，结构体和类的有效对齐值</h3>
<p>有效对齐值 = min{自身对齐值，当前指定对齐值}</p>
<h2 id="四结构体数据的对齐问题">四.结构体数据的对齐问题</h2>
<p>数据结构中的数据变量都是按照定义的先后顺寻进行存放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整 (即结构体成员变量占用总长度为结构体有效对齐值的整数倍) 。</p>
<ol>
<li>结构体字节对齐的细节和具体编译器实现相关，但一般而言满足三个准则： 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；</li>
<li>结构体每个成员相对结构体首地址的偏移量(offset注意偏移量是从0开始的)都是min{本成员大小,当前有效对齐值}的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)；</li>
<li>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。</li>
</ol>
<p>第一条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。</p>
<p>第二条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是min{本成员大小,当前有效对齐值}的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。</p>
<p>第三条：结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第三条，否则就必须在最后填充几个字节以达到本条要求。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ucosii运行流程]]></title>
        <id>https://yvainefire.github.io/post/ucosii-yun-xing-liu-cheng/</id>
        <link href="https://yvainefire.github.io/post/ucosii-yun-xing-liu-cheng/">
        </link>
        <updated>2020-07-28T13:04:04.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="ucosii运行流程">ucosii运行流程</h1>
<h2 id="一系统时钟中断的初始化">一.系统时钟中断的初始化</h2>
<p>SysTick中断初始化，在轮转调度过程中，需要一个时钟中断来进行任务的切换。时钟中断的频率就是系统的心跳，也被称为时基，它决定了操作系统进行任务切换的频率。</p>
<h2 id="二操作系统初始化">二.操作系统初始化</h2>
<h3 id="1osinithookbegin">1.OSInitHookBegin()</h3>
<p>主要进行一些扩展功能的初始化</p>
<h3 id="2os_initmisc">2.OS_InitMisc()</h3>
<p>主要作用：进行杂项变量的初始化，主要有以下内容需要被初始化</p>
<pre><code class="language-c">OSIntNesting    		中断嵌套层数清零
OSLockNesting			
OSTaskCtr				任务计数清零
OSRunning				操作系统运行标志位清零
OSCtxSwCtr				任务切换计数清零
OSIdleCtr				
</code></pre>
<h3 id="3os_initrdylist">3.OS_InitRdyList()</h3>
<p>就绪队列的初始化，所谓就绪队列指由就绪任务构成的队列，但是这里实际上初始化的并不是队列，就绪队列里面保存的也不是就绪任务的TCB。</p>
<pre><code class="language-c">//以下是就绪队列实现的定义和初始化的代码
typedef unsigned char INT8U;

typedef  INT8U    OS_PRIO;

OS_EXT  OS_PRIO           OSRdyTbl[OS_RDY_TBL_SIZE];

for (i = 0u; i &lt; OS_RDY_TBL_SIZE; i++) {
        OSRdyTbl[i] = 0u;
    }

</code></pre>
<p>从这里可以看出，就绪队列的本质是一个8位无符号整型数组，仅仅保存的是一个整型，而不是TCB或者TCB指针。</p>
<p>为什么仅仅保存整型就可以表示就绪队列呢？这个以后再说。</p>
<p>除了初始化就绪队列，还初始化了两个与优先级相关的变量以及两个和任务TCB相关的量。<br>
OSPrioCur	   		保存当前任务的优先级<br>
OSPrioHighRdy      保存当前就绪队列优先级最高的任务的优先级<br>
OSTCBCur 	          保存当前任务的TCB指针<br>
OSTCBHighRdy      保存当前就绪队列中最高优先级任务的TCB指针</p>
<h3 id="4os_inittcblist">4.OS_InitTCBList ()</h3>
<p>初始化TCB链表，这里主要强调的链表，主要是把在头文件里声明的</p>
<p>OS_TCB	OSTCBTbl[OS_MAX_TASKS + OS_N_SYS_TASKS];		这个TCB数组拆开然后用指针将其连接起来。</p>
<pre><code class="language-c">for (ix = 0u; ix &lt; (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
        ix_next =  ix + 1u;
        ptcb1   = &amp;OSTCBTbl[ix];
        ptcb2   = &amp;OSTCBTbl[ix_next];
        ptcb1-&gt;OSTCBNext = ptcb2;
}

ptcb1                   = &amp;OSTCBTbl[ix];
ptcb1-&gt;OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
OSTCBFreeList           = &amp;OSTCBTbl[0];
</code></pre>
<p>除了进行free TCBs的初始化，还会进行以下两个变量的初始化</p>
<pre><code>OS_MemClr((INT8U *)&amp;OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
/*这里采取的强制转换很有意思。
OSTCBList	= (OS_TCB *)0;
</code></pre>
<p>OSTCBPrioTbl[]是用来存放对应的下标为优先级的任务的TCB指针，若该对应下标的任务已经被创建才会有相应的TCB指针，否则保持初始化的空值。这个表的作用是为了快速找个某一优先级对应的任务的任务指针。</p>
<p>OSTCBList就是指向任务块链表的头指针，这里面的任务包括当前所有存在的任务，就绪的，未就绪的。</p>
<h3 id="5os_initeventlist">5.OS_InitEventList()</h3>
<p>事件控制块链表的初始化，这个属于扩展的功能，与任务之间的通信相关，所以就先不讨论了，等到任务通信这个模块再进行讨论。</p>
<h2 id="三任务的创建">三.任务的创建</h2>
<h3 id="1任务函数的格式">1.任务函数的格式</h3>
<p>在ucosii中任务的形式如下：</p>
<p>实际上任务就是一个不带返回值具有死循环的函数</p>
<pre><code class="language-c">void task(void *p_arg)
{		
		while(1)
		{

		}
		
}
</code></pre>
<h3 id="2ostaskcreate">2.OSTaskCreate(）</h3>
<p>任务的创建</p>
<pre><code class="language-c">INT8U  OSTaskCreate (void   (*task)(void *p_arg),
                     void    *p_arg,
                     OS_STK  *ptos,
                     INT8U    prio)
    //任务函数
    //任务所需的参数
    //堆栈
    //优先级
</code></pre>
<ul>
<li>
<p>确保未在ISR中进行任务的创建。利用中断的嵌套层数OSIntNesting进行判断</p>
</li>
<li>
<p>对相应优先级的任务对应的OSTCBPrioTbl[prio]进行占位。由于ucosii仅支持的同一优先级的任务仅有一个，所以需先判断正在创建的任务的优先级是否已经被占用了。</p>
</li>
<li>
<p>堆栈初始化</p>
<pre><code class="language-c"> OS_STK *OSTaskStkInit (void (*task)(void *p_arg), 
 void *p_arg, OS_STK *ptos, INT16U opt)
</code></pre>
<p>所谓堆栈的初始化实际上就是对相关的寄存器进行模拟压栈的操作，并返回压栈后的栈顶指针。模拟压栈就是模仿任务切换时对相应寄存器进行的压栈操作。在这里主要的功能是确定堆栈栈顶指针的位置，同时把设置LR寄存器的值，并保存任务函数的地址，以及任务函数的参数指针。而其余的几个寄存器的值在这时是无意义的，不必关心其模拟压栈的内容。<br>
但是堆栈初始化相对任务切换时的堆栈也有一定的区别：<br>
第一个保存的值本该是PC，但实际上是目前是还没有运行过的，所以保存的是函数的入口地址，即task的地址。<br>
r0保存的值也需要特别注意，r0保存的值是函数的参数指针<br>
cpsr要保存的值也需要手动设置，设置为svc模式同时打开irq和fiq<br>
返回值也要注意是，当前指针的的栈顶位置。</p>
</li>
<li>
<p>TCB初始化</p>
<p>OS_TCBInit()</p>
<ul>
<li>从OSTCBFreeList获得一个空的tcb</li>
<li>把任务的相关信息放到这个空的tcb的相应位置</li>
<li>把被占位的OSTCBPrioTbl[]进行赋值，ptcb</li>
<li>把该tcb链入TCB链表</li>
<li>把该任务放进就绪队列</li>
</ul>
</li>
<li>
<p>是否开始调度</p>
<p>在这里还不会进行调度，因为调度的条件是OSRunning == OS_TRUE，而现在OSRunning == OS_FALSE。</p>
<p>OS_Sched()     //Schedule only if all ISRs done</p>
<ul>
<li>OS_SchedNew()  获得当前就绪队列中的最高的优先级，采用优先级位图的方式直接获得</li>
<li>判断当前执行的任务是否为最高优先级的任务，若不是则调用OS_TASK_SW()则进行任务切换。</li>
</ul>
</li>
</ul>
<h2 id="四操作系统的启动">四.操作系统的启动</h2>
<p>OSStart()</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="ucosii运行流程">ucosii运行流程</h1>
<h2 id="一系统时钟中断的初始化">一.系统时钟中断的初始化</h2>
<p>SysTick中断初始化，在轮转调度过程中，需要一个时钟中断来进行任务的切换。时钟中断的频率就是系统的心跳，也被称为时基，它决定了操作系统进行任务切换的频率。</p>
<h2 id="二操作系统初始化">二.操作系统初始化</h2>
<h3 id="1osinithookbegin">1.OSInitHookBegin()</h3>
<p>主要进行一些扩展功能的初始化</p>
<h3 id="2os_initmisc">2.OS_InitMisc()</h3>
<p>主要作用：进行杂项变量的初始化，主要有以下内容需要被初始化</p>
<pre><code class="language-c">OSIntNesting    		中断嵌套层数清零
OSLockNesting			
OSTaskCtr				任务计数清零
OSRunning				操作系统运行标志位清零
OSCtxSwCtr				任务切换计数清零
OSIdleCtr				
</code></pre>
<h3 id="3os_initrdylist">3.OS_InitRdyList()</h3>
<p>就绪队列的初始化，所谓就绪队列指由就绪任务构成的队列，但是这里实际上初始化的并不是队列，就绪队列里面保存的也不是就绪任务的TCB。</p>
<pre><code class="language-c">//以下是就绪队列实现的定义和初始化的代码
typedef unsigned char INT8U;

typedef  INT8U    OS_PRIO;

OS_EXT  OS_PRIO           OSRdyTbl[OS_RDY_TBL_SIZE];

for (i = 0u; i &lt; OS_RDY_TBL_SIZE; i++) {
        OSRdyTbl[i] = 0u;
    }

</code></pre>
<p>从这里可以看出，就绪队列的本质是一个8位无符号整型数组，仅仅保存的是一个整型，而不是TCB或者TCB指针。</p>
<p>为什么仅仅保存整型就可以表示就绪队列呢？这个以后再说。</p>
<p>除了初始化就绪队列，还初始化了两个与优先级相关的变量以及两个和任务TCB相关的量。<br>
OSPrioCur	   		保存当前任务的优先级<br>
OSPrioHighRdy      保存当前就绪队列优先级最高的任务的优先级<br>
OSTCBCur 	          保存当前任务的TCB指针<br>
OSTCBHighRdy      保存当前就绪队列中最高优先级任务的TCB指针</p>
<h3 id="4os_inittcblist">4.OS_InitTCBList ()</h3>
<p>初始化TCB链表，这里主要强调的链表，主要是把在头文件里声明的</p>
<p>OS_TCB	OSTCBTbl[OS_MAX_TASKS + OS_N_SYS_TASKS];		这个TCB数组拆开然后用指针将其连接起来。</p>
<pre><code class="language-c">for (ix = 0u; ix &lt; (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
        ix_next =  ix + 1u;
        ptcb1   = &amp;OSTCBTbl[ix];
        ptcb2   = &amp;OSTCBTbl[ix_next];
        ptcb1-&gt;OSTCBNext = ptcb2;
}

ptcb1                   = &amp;OSTCBTbl[ix];
ptcb1-&gt;OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
OSTCBFreeList           = &amp;OSTCBTbl[0];
</code></pre>
<p>除了进行free TCBs的初始化，还会进行以下两个变量的初始化</p>
<pre><code>OS_MemClr((INT8U *)&amp;OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
/*这里采取的强制转换很有意思。
OSTCBList	= (OS_TCB *)0;
</code></pre>
<p>OSTCBPrioTbl[]是用来存放对应的下标为优先级的任务的TCB指针，若该对应下标的任务已经被创建才会有相应的TCB指针，否则保持初始化的空值。这个表的作用是为了快速找个某一优先级对应的任务的任务指针。</p>
<p>OSTCBList就是指向任务块链表的头指针，这里面的任务包括当前所有存在的任务，就绪的，未就绪的。</p>
<h3 id="5os_initeventlist">5.OS_InitEventList()</h3>
<p>事件控制块链表的初始化，这个属于扩展的功能，与任务之间的通信相关，所以就先不讨论了，等到任务通信这个模块再进行讨论。</p>
<h2 id="三任务的创建">三.任务的创建</h2>
<h3 id="1任务函数的格式">1.任务函数的格式</h3>
<p>在ucosii中任务的形式如下：</p>
<p>实际上任务就是一个不带返回值具有死循环的函数</p>
<pre><code class="language-c">void task(void *p_arg)
{		
		while(1)
		{

		}
		
}
</code></pre>
<h3 id="2ostaskcreate">2.OSTaskCreate(）</h3>
<p>任务的创建</p>
<pre><code class="language-c">INT8U  OSTaskCreate (void   (*task)(void *p_arg),
                     void    *p_arg,
                     OS_STK  *ptos,
                     INT8U    prio)
    //任务函数
    //任务所需的参数
    //堆栈
    //优先级
</code></pre>
<ul>
<li>
<p>确保未在ISR中进行任务的创建。利用中断的嵌套层数OSIntNesting进行判断</p>
</li>
<li>
<p>对相应优先级的任务对应的OSTCBPrioTbl[prio]进行占位。由于ucosii仅支持的同一优先级的任务仅有一个，所以需先判断正在创建的任务的优先级是否已经被占用了。</p>
</li>
<li>
<p>堆栈初始化</p>
<pre><code class="language-c"> OS_STK *OSTaskStkInit (void (*task)(void *p_arg), 
 void *p_arg, OS_STK *ptos, INT16U opt)
</code></pre>
<p>所谓堆栈的初始化实际上就是对相关的寄存器进行模拟压栈的操作，并返回压栈后的栈顶指针。模拟压栈就是模仿任务切换时对相应寄存器进行的压栈操作。在这里主要的功能是确定堆栈栈顶指针的位置，同时把设置LR寄存器的值，并保存任务函数的地址，以及任务函数的参数指针。而其余的几个寄存器的值在这时是无意义的，不必关心其模拟压栈的内容。<br>
但是堆栈初始化相对任务切换时的堆栈也有一定的区别：<br>
第一个保存的值本该是PC，但实际上是目前是还没有运行过的，所以保存的是函数的入口地址，即task的地址。<br>
r0保存的值也需要特别注意，r0保存的值是函数的参数指针<br>
cpsr要保存的值也需要手动设置，设置为svc模式同时打开irq和fiq<br>
返回值也要注意是，当前指针的的栈顶位置。</p>
</li>
<li>
<p>TCB初始化</p>
<p>OS_TCBInit()</p>
<ul>
<li>从OSTCBFreeList获得一个空的tcb</li>
<li>把任务的相关信息放到这个空的tcb的相应位置</li>
<li>把被占位的OSTCBPrioTbl[]进行赋值，ptcb</li>
<li>把该tcb链入TCB链表</li>
<li>把该任务放进就绪队列</li>
</ul>
</li>
<li>
<p>是否开始调度</p>
<p>在这里还不会进行调度，因为调度的条件是OSRunning == OS_TRUE，而现在OSRunning == OS_FALSE。</p>
<p>OS_Sched()     //Schedule only if all ISRs done</p>
<ul>
<li>OS_SchedNew()  获得当前就绪队列中的最高的优先级，采用优先级位图的方式直接获得</li>
<li>判断当前执行的任务是否为最高优先级的任务，若不是则调用OS_TASK_SW()则进行任务切换。</li>
</ul>
</li>
</ul>
<h2 id="四操作系统的启动">四.操作系统的启动</h2>
<p>OSStart()</p>
<!-- more -->
<h3 id="1判断osrunning-os_false">1.判断OSRunning == OS_FALSE</h3>
<h3 id="2os_schednew">2.OS_SchedNew()</h3>
<p>获得当前就绪队列中的最高的优先级，采用优先级位图的方式直接获得</p>
<h3 id="3设置ospriocurostcbhighrdyostcbcur">3.设置OSPrioCur，OSTCBHighRdy，OSTCBCur</h3>
<h3 id="4osstarthighrdy">4.OSStartHighRdy()</h3>
<p>设置PendSV的中断优先级</p>
<p>初始化PSP</p>
<p>设置OSRunning标志为1</p>
<p>开启PendSV中断。</p>
]]></content>
    </entry>
</feed>